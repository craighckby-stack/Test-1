// core/SchemaValidator_Engine.js
import { XEL_Specification } from '../config/XEL_Specification.json';
import Ajv from 'ajv'; 
// IMPORTING EMERGENT CAPABILITY: Decouples navigation strategy synthesis from core validation
import { SchemaFailureAnalyzer } from '../emergent/meta_tools/SchemaFailureAnalyzer.js'; 
// IMPORTING PLUGIN: Abstracts error keyword analysis for Meta-Reasoning
import { ErrorCapabilityMapper } from '../plugins/ErrorCapabilityMapper.js'; 

/**
 * Custom error class for structured, machine-readable validation failures.
 */
class SchemaValidationError extends Error {
    constructor(schemaName, errors) {
        // Use a temporary Ajv instance to access the errorsText utility cleanly
        const tempAjv = new Ajv();
        // Fallback for potentially malformed errors structure
        const errorText = errors && Array.isArray(errors) 
            ? tempAjv.errorsText(errors, { separator: '; ', dataVar: schemaName })
            : 'Validation context missing or malformed.';
        
        // LOGIC IMPROVEMENT: Include the most critical error keyword in the top-level message
        const criticalKeyword = errors && errors.length > 0 ? `[${errors[0].keyword}]` : '';
        
        super(`XEL Validation Failed [${schemaName}] ${criticalKeyword}: ${errorText}`);
        this.name = 'SchemaValidationError';
        this.schemaName = schemaName; 
        this.validationErrors = errors; // Raw Ajv errors for programmatic handling
    }
}

/**
 * Defines the structured output used by the AGI Navigator System for dynamic weighting.
 * This structure is generated by internal self-diagnostic analysis (Meta-Learning).
 * @typedef {Object} NavigatorSuggestion
 * @property {string} path - The relative file path to target (e.g., 'core/TaskScheduler.js').
 * @property {string} reason - Justification for the weight increase.
 * @property {number} increasedWeight - The weight factor to add (0.0 to 1.0).
 * @property {string} originatingCapability - The AGI Capability that suffered the failure (e.g., 'Logic', 'Memory', 'Navigation').
 */

/**
 * The Schema Validator enforces the structural integrity of data across the XEL environment.
 * It is designed for robustness (Error Handling) and dynamic updates (Autonomy).
 */
class SchemaValidatorEngine {
    
    // Private static field for configuration
    static #MAX_HISTORY = 100; // Store the last 100 failures

    // Private instance fields for strong encapsulation
    #validator = null;
    #kernelVersion;
    #schemaComponentMap;
    #onValidationFailure;
    #capabilityMapper;
    #runtimeMapper;
    #failureHistory = [];
    #analyzer;

    /**
     * @param {object} options - Configuration options.
     * @param {object} [options.componentSchemas] - Schema definitions to override defaults.
     * @param {function} [options.onValidationFailure] - Callback function for Nexus/MQM logging. (mqmPayload, failureEntry)
     * @param {string} [options.kernelVersion='N/A'] - The current kernel version for dynamic reporting (Meta-Reasoning).
     * @param {object} [options.schemaComponentMap] - Map of schemaName -> {componentPath: string, priority: number} for Navigation targeting.
     * @param {function} [options.runtimeMapper] - Injectable function for mapping keywords to capabilities (overrides fallback).
     */
    constructor(options = {}) {
        const { 
            componentSchemas, 
            onValidationFailure,
            kernelVersion = 'N/A', 
            schemaComponentMap = {},
            runtimeMapper
        } = options;
        
        // Expose error type publicly for consumer convenience/error handling compatibility
        this.SchemaValidationError = SchemaValidationError;
        
        // Store dynamic runtime metadata privately
        this.#kernelVersion = kernelVersion;
        this.#schemaComponentMap = schemaComponentMap;
        
        // INTEGRATION HOOK: Function provided by the kernel core
        this.#onValidationFailure = onValidationFailure || (() => {}); 

        // LOGIC REFACTOR: Keyword-to-Capability mapping is outsourced to ErrorCapabilityMapper plugin.
        if (runtimeMapper) {
            this.#runtimeMapper = runtimeMapper;
        } else {
            // Initialize private mapper dependency
            this.#capabilityMapper = new ErrorCapabilityMapper();
            // Bind the method to ensure 'this' context works correctly within the mapper instance
            this.#runtimeMapper = this.#capabilityMapper.mapKeywordToCapability.bind(this.#capabilityMapper);
        }

        // Meta-Reasoning: Persistent tracking of validation failures for pattern recognition
        this.#failureHistory = []; 
        
        // Initialize validator using provided schemas or default imported ones
        this.#initializeValidator(componentSchemas || XEL_Specification.ComponentSchemas);

        // Architectural Refactoring: Initialize the Emergent Failure Analyzer
        this.#analyzer = new SchemaFailureAnalyzer({
            schemaComponentMap: this.#schemaComponentMap
        });
    }

    /**
     * Initializes or re-initializes the Ajv instance. This supports dynamic schema updates
     * when the AGI kernel autonomously modifies configuration files (Autonomy/Infrastructure).
     * @param {object} componentSchemas - Map of schema names to JSON Schema definitions.
     */
    #initializeValidator(componentSchemas) {
        // Configuration for maximum robustness and data hygiene:
        this.#validator = new Ajv({
            allErrors: true,
            strict: true,
            removeAdditional: 'all' 
        });

        // Add all schemas dynamically
        if (componentSchemas && typeof componentSchemas === 'object' && !Array.isArray(componentSchemas)) {
            Object.entries(componentSchemas).forEach(([name, schema]) => {
                try {
                    // Check if schema is already defined to avoid strict mode errors on re-init
                    if (this.#validator.getSchema(name)) {
                         this.#validator.removeSchema(name);
                    }
                    this.#validator.addSchema(schema, name);
                } catch (e) {
                    // Log schema registration failure, but continue initialization
                    console.error(`[SCHEMA_ENGINE]: Failed to register schema ${name}:`, e.message);
                }
            });
        }
    }

    /**
     * Public method to manually trigger a schema refresh, allowing the kernel
     * to update specifications without a full reboot (Autonomy).
     * @param {object} newSpecification - The new ComponentSchemas object.
     */
    refreshSchemas(newSpecification) {
        // Clear old instance and re-initialize
        this.#initializeValidator(newSpecification);
    }

    /**
     * Internal method to log validation failures for Meta-Reasoning analysis and trigger MQM/Nexus logging.
     */
    #trackFailure(schemaName, errors, isCritical, dataSample) {
        // 1. Prepare history and summary
        const summary = errors?.map(e => ({
            path: e.instancePath || e.dataPath || 'N/A',
            keyword: e.keyword,
            message: e.message
        })) || [];
        
        // Determine Capability Impact dynamically (Meta-Reasoning)
        const firstErrorKeyword = summary[0]?.keyword || 'N/A';
        
        // REFACTORED: Use the private runtime mapper
        const capabilityImpact = this.#runtimeMapper(firstErrorKeyword);

        const failureEntry = {
            timestamp: Date.