// src/config/DialAnalysisConfigValidator.js

// NOTE: StructuralConfigSchemaValidatorTool is assumed to be available via injection
// or a global kernel interface for delegation, as defined in the 'plugin' section.
const StructuralConfigSchemaValidator = {
    // Mock interface provided by AGI Kernel for delegation
    validate: (config, schema) => {
        if (!config) throw new Error("Configuration map is null or undefined.");

        // Access the actual vanilla JS tool logic
        // In a real environment, this might be directly imported or injected.
        if (typeof __KERNEL__ !== 'undefined' && __KERNEL__.plugins.StructuralConfigSchemaValidatorTool) {
            return __KERNEL__.plugins.StructuralConfigSchemaValidatorTool.validate(config, schema);
        } 
        // Fallback for environment without kernel/injection (for testing)
        // This line would typically be removed in a controlled environment.
        throw new Error("StructuralConfigSchemaValidatorTool dependency missing.");
    }
};

/**
 * Utility class responsible for loading, validating, and normalizing the Dial Analysis Configuration Map.
 * This decouples runtime logic from configuration schema concerns.
 */
class DialAnalysisConfigValidator {

    /**
     * Defines the high-level structural schema for Dial Analysis Configuration.
     */
    static DIAL_ANALYSIS_SCHEMA = [
        { key: 'metrics_config', type: 'object', required: true },
        { key: 'precondition_definitions', type: 'object', required: true },
        // Enforcing 'array' type, correcting the ambiguity of the original 'object' check
        { key: 'response_rules', type: 'array', required: true }
    ];

    /**
     * Validates and returns a standardized configuration object.
     * @param {Object} rawConfig The raw JSON configuration object (e.g., dial_analysis_map.json).
     * @returns {Object} The validated and normalized configuration.
     * @throws {Error} If the configuration fails validation checks.
     */
    static validate(rawConfig) {
        
        // 1. Basic Structure Check (Delegated to reusable tool)
        if (!rawConfig) {
            throw new Error("Configuration map is null or undefined.");
        }

        try {
            StructuralConfigSchemaValidator.validate(rawConfig, DialAnalysisConfigValidator.DIAL_ANALYSIS_SCHEMA);
        } catch (e) {
            // Re-throw specific errors generated by the structural validator
            throw new Error(`Configuration structural error: ${e.message}`);
        }

        const config = rawConfig; // Now guaranteed to have basic structure

        // 2. Metric and Precondition Consistency Check (Domain-specific validation)
        for (const [pKey, definition] of Object.entries(config.precondition_definitions)) {
            if (!definition || typeof definition !== 'object') {
                throw new Error(`Precondition definition for ${pKey} is invalid.`);
            }
            if (!definition.check || typeof definition.check !== 'string') {
                 throw new Error(`Precondition ${pKey} is missing a 'check' field defining the metric or 'check' is not a string.`);
            }
            const targetMetricKey = definition.check;
            
            if (!config.metrics_config[targetMetricKey]) {
                throw new Error(`Metric configuration missing for precondition target: ${targetMetricKey} referenced by precondition ${pKey}`);
            }
        }

        // 3. Rule Structure Normalization
        config.response_rules = config.response_rules.map(rule => {
            if (typeof rule !== 'object' || rule === null) {
                throw new Error("Response rule entry is invalid or null.");
            }
            return {
                ...rule,
                // Ensure every rule has a defined priority, defaulting to 0
                priority: rule.priority || 0
            };
        });

        return config;
    }
}

export default DialAnalysisConfigValidator;
