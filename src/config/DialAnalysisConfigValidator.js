// src/config/DialAnalysisConfigValidator.js

// NOTE: This module assumes 'StructuralConfigSchemaValidatorTool' is available 
// (e.g., imported or injected by the kernel environment) for delegation.

/**
 * Utility class responsible for loading, validating, and normalizing the Dial Analysis Configuration Map.
 * This decouples runtime logic from configuration schema concerns by delegating structural checks.
 */
class DialAnalysisConfigValidator {

    /**
     * Defines the high-level structural schema for Dial Analysis Configuration.
     */
    static DIAL_ANALYSIS_SCHEMA = [
        { key: 'metrics_config', type: 'object', required: true },
        { key: 'precondition_definitions', type: 'object', required: true },
        // Enforcing 'array' type
        { key: 'response_rules', type: 'array', required: true }
    ];

    /**
     * Validates and returns a standardized configuration object.
     * @param {Object} rawConfig The raw JSON configuration object (e.g., dial_analysis_map.json).
     * @param {Object} StructuralConfigSchemaValidatorTool Tool provided by the Kernel for schema checking.
     * @returns {Object} The validated and normalized configuration.
     * @throws {Error} If the configuration fails validation checks.
     */
    static validate(rawConfig, StructuralConfigSchemaValidatorTool) {
        
        // 1. Basic Structure Check (Delegated to reusable tool)
        if (!rawConfig) {
            throw new Error("Configuration map is null or undefined.");
        }
        
        if (!StructuralConfigSchemaValidatorTool || typeof StructuralConfigSchemaValidatorTool.validate !== 'function') {
             throw new Error("Dependency 'StructuralConfigSchemaValidatorTool' is missing or invalid.");
        }

        try {
            StructuralConfigSchemaValidatorTool.validate(rawConfig, DialAnalysisConfigValidator.DIAL_ANALYSIS_SCHEMA);
        } catch (e) {
            // Re-throw specific errors generated by the structural validator
            throw new Error(`Configuration structural error: ${e.message}`);
        }

        const config = rawConfig; // Now guaranteed to have basic structure

        // 2. Metric and Precondition Consistency Check (Domain-specific validation)
        for (const [pKey, definition] of Object.entries(config.precondition_definitions)) {
            if (!definition || typeof definition !== 'object') {
                throw new Error(`Precondition definition for ${pKey} is invalid.`);
            }
            if (!definition.check || typeof definition.check !== 'string') {
                 throw new Error(`Precondition ${pKey} is missing a 'check' field defining the metric or 'check' is not a string.`);
            }
            const targetMetricKey = definition.check;
            
            if (!config.metrics_config[targetMetricKey]) {
                throw new Error(`Metric configuration missing for precondition target: ${targetMetricKey} referenced by precondition ${pKey}`);
            }
        }

        // 3. Rule Structure Normalization
        config.response_rules = config.response_rules.map(rule => {
            if (typeof rule !== 'object' || rule === null) {
                throw new Error("Response rule entry is invalid or null.");
            }
            return {
                ...rule,
                // Ensure every rule has a defined priority, defaulting to 0
                priority: rule.priority || 0
            };
        });

        return config;
    }
}

export default DialAnalysisConfigValidator;