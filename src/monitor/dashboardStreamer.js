/**
 * @module DashboardStreamer
 * @description Manages continuous polling and streaming of runtime reports generated by RuntimeDashboard.
 * Uses an internal buffer and a basic observer pattern (via ObserverPatternUtility) to allow components 
 * (e.g., UI, persistent logging) to subscribe to real-time metric updates without direct polling.
 */

import { generateRuntimeReport } from './runtimeDashboard';

// CRITICAL: Initialize the emitter using the extracted plugin
// @ts-ignore
const emitter = AGI_KERNEL.plugins.ObserverPatternUtility.createInstance();

const POLL_INTERVAL_MS = 2500; // Update every 2.5 seconds
// Using recursive setTimeout requires clearTimeout. This variable stores the handle for the next scheduled call.
let intervalHandle: NodeJS.Timeout | null = null;
let latestReport: Record<string, any> = {};
let isPollingActive: boolean = false; // State flag for controlling the recursive loop

/**
 * Notifies all subscribed listeners with the new report.
 * Delegation of notification and error handling to the plugin.
 * @param {Object} report The latest runtime report.
 */
function notifySubscribers(report: Record<string, any>): void {
    emitter.notify(report);
}

/**
 * Starts the continuous polling process using recursive setTimeout.
 * This pattern ensures that the next poll only starts after the previous one completes,
 * preventing overlap if generateRuntimeReport takes longer than POLL_INTERVAL_MS.
 */
export function startDashboardStream(): void {
    if (isPollingActive) {
        console.warn('Dashboard stream is already active.');
        return;
    }

    isPollingActive = true;
    console.log(`Starting dashboard stream (Interval: ${POLL_INTERVAL_MS}ms)`);

    const pollAndSchedule = async () => {
        if (!isPollingActive) return; // Exit condition 1

        try {
            // 1. Generate report and notify
            latestReport = await generateRuntimeReport();
            notifySubscribers(latestReport);
        } catch (error) {
            console.error("Error during runtime report generation:", error);
            // Continue polling, but log the failure
        }

        // 2. Schedule the next poll only if the system is still active
        if (isPollingActive) {
            intervalHandle = setTimeout(pollAndSchedule, POLL_INTERVAL_MS);
        }
    };

    // Initiate the process immediately
    pollAndSchedule();
}

/**
 * Stops the continuous polling process.
 */
export function stopDashboardStream(): void {
    if (!isPollingActive) return;

    isPollingActive = false; // Stop the recursive loop logic

    if (intervalHandle) {
        clearTimeout(intervalHandle);
        intervalHandle = null;
        console.log('Dashboard stream stopped.');
    }
}

/**
 * Subscribes a listener function to receive updates.
 * @param {Function} callback Function that accepts the report object as an argument.
 */
export function subscribeToReports(callback: (report: Record<string, any>) => void): void {
    emitter.subscribe(callback);
    // Immediately provide the latest snapshot upon subscription, if data exists.
    if (Object.keys(latestReport).length > 0) {
        callback(latestReport);
    }
}

/**
 * Unsubscribes a listener function.
 * @param {Function} callback The function to remove.
 */
export function unsubscribeFromReports(callback: (report: Record<string, any>) => void): void {
    emitter.unsubscribe(callback);
}