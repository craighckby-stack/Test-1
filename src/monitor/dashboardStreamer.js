/**
 * @module DashboardStreamer
 * @description Manages continuous polling and streaming of runtime reports generated by RuntimeDashboard.
 * Uses an internal buffer and a basic observer pattern (via ObserverPatternUtility) to allow components 
 * (e.g., UI, persistent logging) to subscribe to real-time metric updates without direct polling.
 */

import { generateRuntimeReport } from './runtimeDashboard';

// CRITICAL: Initialize the emitter using the extracted plugin
// @ts-ignore
const emitter = AGI_KERNEL.plugins.ObserverPatternUtility.createInstance();

const POLL_INTERVAL_MS = 2500; // Update every 2.5 seconds
let intervalHandle: NodeJS.Timeout | null = null;
let latestReport: Record<string, any> = {};

/**
 * Starts the continuous polling process.
 */
export function startDashboardStream(): void {
    if (intervalHandle) {
        console.warn('Dashboard stream is already active.');
        return;
    }

    console.log(`Starting dashboard stream (Interval: ${POLL_INTERVAL_MS}ms)`);

    const poll = async () => {
        try {
            latestReport = await generateRuntimeReport();
            notifySubscribers(latestReport);
        } catch (error) {
            console.error("Error during runtime report generation:", error);
            // Continue polling, but log the failure
        }
    };

    // Initial run immediately
    poll();

    intervalHandle = setInterval(poll, POLL_INTERVAL_MS);
}

/**
 * Stops the continuous polling process.
 */
export function stopDashboardStream(): void {
    if (intervalHandle) {
        clearInterval(intervalHandle);
        intervalHandle = null;
        console.log('Dashboard stream stopped.');
    }
}

/**
 * Subscribes a listener function to receive updates.
 * @param {Function} callback Function that accepts the report object as an argument.
 */
export function subscribeToReports(callback: (report: Record<string, any>) => void): void {
    emitter.subscribe(callback);
    // Immediately provide the latest snapshot upon subscription, if data exists.
    if (Object.keys(latestReport).length > 0) {
        callback(latestReport);
    }
}

/**
 * Unsubscribes a listener function.
 * @param {Function} callback The function to remove.
 */
export function unsubscribeFromReports(callback: (report: Record<string, any>) => void): void {
    emitter.unsubscribe(callback);
}

/**
 * Notifies all subscribed listeners with the new report.
 * Delegation of notification and error handling to the plugin.
 * @param {Object} report The latest runtime report.
 */
function notifySubscribers(report: Record<string, any>): void {
    emitter.notify(report);
}
