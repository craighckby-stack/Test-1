/**
 * @module DashboardStreamer
 * @description Manages continuous polling and streaming of runtime reports generated by RuntimeDashboard.
 * Uses an internal buffer and a basic observer pattern (via ObserverPatternUtility) to allow components 
 * (e.g., UI, persistent logging) to subscribe to real-time metric updates without direct polling.
 */

import { generateRuntimeReport } from './runtimeDashboard';

// CRITICAL: Initialize the emitter and the poller using extracted plugins
// @ts-ignore
const emitter = AGI_KERNEL.plugins.ObserverPatternUtility.createInstance();
// @ts-ignore
const poller = AGI_KERNEL.plugins.ResilientPollerUtility.createInstance('DashboardStreamer');

const POLL_INTERVAL_MS = 2500; // Update every 2.5 seconds
let latestReport: Record<string, any> = {};

/**
 * Notifies all subscribed listeners with the new report.
 * Delegation of notification and error handling to the plugin.
 * @param {Object} report The latest runtime report.
 */
function notifySubscribers(report: Record<string, any>): void {
    emitter.notify(report);
}

/**
 * The core asynchronous task executed by the ResilientPoller.
 * Generates the report and notifies subscribers.
 */
const dashboardTask = async (): Promise<void> => {
    // 1. Generate report and notify
    const report = await generateRuntimeReport();
    latestReport = report;
    notifySubscribers(latestReport);
    // Note: Error handling for generateRuntimeReport is now centralized in the ResilientPollerUtility
};


/**
 * Starts the continuous polling process using the ResilientPollerUtility.
 */
export function startDashboardStream(): void {
    if (poller.isActive()) {
        console.warn('Dashboard stream is already active.');
        return;
    }
    
    poller.start(dashboardTask, POLL_INTERVAL_MS);
}

/**
 * Stops the continuous polling process.
 */
export function stopDashboardStream(): void {
    poller.stop();
}

/**
 * Subscribes a listener function to receive updates.
 * @param {Function} callback Function that accepts the report object as an argument.
 */
export function subscribeToReports(callback: (report: Record<string, any>) => void): void {
    emitter.subscribe(callback);
    // Immediately provide the latest snapshot upon subscription, if data exists.
    if (Object.keys(latestReport).length > 0) {
        callback(latestReport);
    }
}

/**
 * Unsubscribes a listener function.
 * @param {Function} callback The function to remove.
 */
export function unsubscribeFromReports(callback: (report: Record<string, any>) => void): void {
    emitter.unsubscribe(callback);
}