import { IRegistryInitializerToolKernel } from '@AGI/tools/IRegistryInitializerToolKernel';
import { ConfigSchemaRegistryKernel } from '@AGI/registries/ConfigSchemaRegistryKernel';

/**
 * M01PolicySchemaKernel
 * 
 * Defines and registers the M01 Refinement Proposal Schema structure 
 * asynchronously using the ConfigSchemaRegistryKernel.
 * 
 * RATIONALE: This eliminates the critical architectural violation of synchronous
 * schema definition and reliance on ad-hoc global utility methods (DescriptiveSchemaFactory.execute()),
 * ensuring schemas are managed as auditable, asynchronously loadable configurations 
 * mandated by the AIA Enforcement Layer. It achieves Maximum Recursive Abstraction 
 * by delegating persistence to specialized registry kernels.
 */
export class M01PolicySchemaKernel {
    // ACTIVE_TOOLS: [ConfigSchemaRegistryKernel, IRegistryInitializerToolKernel]
    constructor(registryInitializerTool, configSchemaRegistry) {
        // AIA ENFORCEMENT: Strictly enforce dependency injection of specialized kernels.
        if (!registryInitializerTool || !configSchemaRegistry) {
            throw new Error("M01PolicySchemaKernel requires RegistryInitializerToolKernel and ConfigSchemaRegistryKernel.");
        }
        this.registryInitializer = registryInitializerTool;
        this.configSchemaRegistry = configSchemaRegistry;
        this.schemaData = this._defineSchemas();
    }

    /**
     * Defines the structure of the M01 Governance Refinement Proposal.
     * Translates the descriptive schema constraints into a serializable structure.
     * @returns {object} The structured schema definition compatible with the ConfigSchemaRegistry.
     */
    _defineSchemas() {
        
        const PolicyRuleSchemaDefinition = {
            type: 'object',
            description: 'Defines the structure for a single, proposed governance rule change.',
            properties: {
                ruleId: { type: 'string', required: true, description: 'Unique identifier for the proposed rule.' },
                ruleType: { 
                    type: 'string', 
                    required: true, 
                    enum: ['VETO', 'WEIGHT', 'LIMIT'], 
                    description: 'Enforcement types recognized by the Constraint Generator.' 
                },
                parameters: { 
                    type: 'object', 
                    required: true, 
                    description: 'Specific parameters defining the rule activation/value (must be non-empty).' 
                },
                justificationMetric: { 
                    type: 'string', 
                    required: true, 
                    description: 'Metric ID from GMRE audit data justifying this rule.' 
                }
            }
        };

        const RefinementProposalSchemaDefinition = {
            type: 'object',
            description: 'Defines the entire M01 Refinement Proposal payload from the GMRE.',
            properties: {
                proposalId: { type: 'string', required: true, description: 'Unique ID generated by the GMRE for this cycle.' },
                schemaVersion: { 
                    type: 'string', 
                    required: true, 
                    enum: ['M01.v1'], 
                    description: 'Schema contract version.' 
                },
                optimalS02Adjustment: { 
                    type: 'number', 
                    optional: true,
                    precision: 4, 
                    description: 'Proposed delta for Risk Floor adjustment (S-02 parameter).'
                },
                recommendedPolicyRules: { 
                    type: 'array', 
                    items: PolicyRuleSchemaDefinition,
                    optional: true,
                    description: 'Proposed additions or modifications to policy rules (VETO, WEIGHT, LIMIT).' 
                },
                auditCycle: { 
                    type: 'string', 
                    required: true, 
                    description: 'The unique identifier for the audit cycle that triggered this proposal.' 
                },
            }
        };
        
        // Use standardized, auditable Concept IDs for registration
        return {
            M01_POLICY_RULE_SCHEMA_ID: PolicyRuleSchemaDefinition,
            M01_REFINEMENT_PROPOSAL_SCHEMA_ID: RefinementProposalSchemaDefinition
        };
    }

    /**
     * Initializes the kernel by registering the defined schemas asynchronously.
     * Mandatory non-blocking initialization method.
     * @returns {Promise<void>}
     */
    async initialize() {
        const registrationPromises = Object.entries(this.schemaData).map(([key, schema]) => {
            return this.registryInitializer.registerAsync(this.configSchemaRegistry, key, schema);
        });

        await Promise.all(registrationPromises);
    }

    // Runtime retrieval methods (synchronous access to cached registry data)
    getPolicyRuleSchema(id = 'M01_POLICY_RULE_SCHEMA_ID') {
        return this.configSchemaRegistry.get(id);
    }
    
    getRefinementProposalSchema(id = 'M01_REFINEMENT_PROPOSAL_SCHEMA_ID') {
        return this.configSchemaRegistry.get(id);
    }
}