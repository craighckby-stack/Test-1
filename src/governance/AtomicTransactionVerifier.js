/**
 * MTV: Mutation Transaction Verifier Kernel (AIA Integrity Auditor)
 * Verifies the cryptographic consistency and internal integrity of 
 * atomic execution artifacts generated by MCR, C04, FBA, and SEA before 
 * final commitment by AEOR. This provides an independent audit layer.
 */
class AtomicTransactionVerifierKernel {

    /**
     * @type {CryptoUtilityInterfaceKernel}
     * @private
     */
    #crypto;

    /**
     * @type {SecureResourceLoaderInterfaceKernel}
     * @private
     */
    #storageLoader;

    /**
     * @type {ILoggerToolKernel} // Assuming ILoggerToolKernel for robust logging/telemetry
     * @private
     */
    #logger;

    /**
     * @type {IIntegrityAuditorToolKernel} // Conceptual interface for the injected auditor
     * @private
     */
    #integrityAuditor; 

    /**
     * @param {object} dependencies - Structured dependencies injection.
     * @param {CryptoUtilityInterfaceKernel} dependencies.crypto - Service for hashing and signing.
     * @param {SecureResourceLoaderInterfaceKernel} dependencies.storageLoader - Secure loader for transaction artifacts.
     * @param {ILoggerToolKernel} dependencies.logger - Logging service (replaces telemetry).
     * @param {IIntegrityAuditorToolKernel} dependencies.integrityAuditor - The abstracted integrity checking plugin.
     */
    constructor(dependencies) {
        this.#setupDependencies(dependencies);
    }

    /**
     * Synchronously sets up and validates required dependencies.
     * @param {object} dependencies
     * @private
     */
    #setupDependencies(dependencies) {
        if (!dependencies.crypto || !dependencies.storageLoader || !dependencies.logger || !dependencies.integrityAuditor) {
            throw new Error("Missing required dependencies for AtomicTransactionVerifierKernel: crypto, storageLoader, logger, integrityAuditor.");
        }
        this.#crypto = dependencies.crypto;
        this.#storageLoader = dependencies.storageLoader;
        this.#logger = dependencies.logger;
        this.#integrityAuditor = dependencies.integrityAuditor;
    }

    /**
     * Executes a specific audit step, handling delegation, result checking, and error logging.
     * This centralizes delegation logic, error handling, and early exit.
     * 
     * @private
     * @param {string} deploymentID
     * @param {string} stepName - Descriptive name for logging.
     * @param {function} auditDelegate - The function to execute (must be bound if necessary).
     * @param {Array<any>} args - Arguments for the auditDelegate.
     * @param {string} successKey - The key in the result object that indicates success ('isConsistent' or 'isValid').
     * @param {string} failureReason - The public reason to return on failure.
     * @returns {Promise<{isVerified: boolean, reason?: string} | null>} Returns failure object or null on success.
     */
    async #executeValidationStep(deploymentID, stepName, auditDelegate, args, successKey, failureReason) {
        this.#logger.debug(`MTV: Executing validation step: ${stepName} for ${deploymentID}.`);
        
        let result;
        try {
            result = await auditDelegate(...args);
        } catch (e) {
            this.#logger.error(`MTV Execution Error in ${stepName}: ${e.message}`, { error: e });
            return { isVerified: false, reason: `Internal error during ${stepName}.` };
        }

        if (!result || !result[successKey]) {
            const detailedReason = result?.reason || "Validation failed without specific reason.";
            this.#logger.error(`MTV Integrity Breach: ${stepName} failed for ${deploymentID}. Detailed Reason: ${detailedReason}`);
            return { isVerified: false, reason: failureReason };
        }
        return null; // Success
    }

    /**
     * Executes the comprehensive integrity check of the transaction artifacts.
     * Ensures consistency between pre-state commitment, execution trace, and post-execution metrics.
     * 
     * @param {string} deploymentID 
     * @param {object} auditContext - Data structure including hashes/signatures from MCR/FBA/SEA.
     * @returns {Promise<{isVerified: boolean, reason?: string}>}
     */
    async verifyTransactionIntegrity(deploymentID, auditContext) {
        this.#logger.debug(`MTV: Starting integrity verification for ${deploymentID}.`);
        
        // 1. Retrieve the attested execution trace from storage
        let traceArtifact;
        try {
            traceArtifact = await this.#storageLoader.loadResource(`trace-artifact://${deploymentID}`);
        } catch (error) {
             this.#logger.error(`MTV Retrieval Error: Failed to load trace artifact for ${deploymentID}.`, { error });
             return { isVerified: false, reason: "Error accessing critical execution trace artifact." };
        }
        
        if (!traceArtifact || !traceArtifact.traceLog) {
            return { isVerified: false, reason: "Missing critical execution trace artifact." };
        }

        // --- 2. Re-calculate and verify hash of the C-04 trace log using centralized execution ---
        
        const hashFunction = this.#crypto.hashArtifact.bind(this.#crypto);

        const hashFailure = await this.#executeValidationStep(
            deploymentID,
            "C04 Trace Hash Check",
            this.#integrityAuditor.verifyHashConsistency.bind(this.#integrityAuditor),
            [traceArtifact.traceLog, auditContext.expectedTraceHash, hashFunction],
            'isConsistent',
            "C04 Execution Trace hash mismatch."
        );
        if (hashFailure) return hashFailure;
        
        // --- 3. Verify SEA/FBA Audit Data Integrity (Signature check) using centralized execution ---

        const verifyFunction = this.#crypto.verifySignature.bind(this.#crypto);

        const signatureFailure = await this.#executeValidationStep(
            deploymentID,
            "Audit Data Signature Check",
            this.#integrityAuditor.verifySignatureIntegrity.bind(this.#integrityAuditor),
            [auditContext.metrics, auditContext.auditSignature, verifyFunction],
            'isValid',
            "SEA/FBA Audit data signature verification failed."
        );
        if (signatureFailure) return signatureFailure;

        this.#logger.info(`MTV: Transaction integrity verified for ${deploymentID}.`);
        return { isVerified: true };
    }
}

module.exports = AtomicTransactionVerifierKernel;