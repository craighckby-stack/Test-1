class Config {
  static get staticConfig() {
    return {
      VERSION: "1.0.0",
      env: process.env.NODE_ENV || "development"
    };
  }

  constructor(values = {}) {
    this.setConfig(values);
  }

  setConfig(values) {
    Object.assign(this, values);
  }

  static get defaultConfig() {
    return {
      foo: 'bar',
      baz: true,
      version: Config.staticConfig.VERSION,
      environment: Config.staticConfig.env
    };
  }

  static get configSchema() {
    return {
      type: 'object',
      properties: {
        foo: { type: 'string' },
        baz: { type: 'boolean' },
        version: { type: 'string' },
        env: { type: 'string' }
      },
      required: ['foo', 'baz', 'version', 'env']
    };
  }

  validate() {
    try {
      const schema = Config.configSchema;
      const validator = new (require('jsonschema').Validator)();
      validator.checkSchema(schema);
      validator.validate(this, schema);
    } catch (e) {
      console.error('Config validation error:', e);
      throw e;
    }
  }
}

class LifecycleEvent {
  #event;

  constructor(event) {
    this.#event = event;
  }

  get event() {
    return this.#event;
  }

  setEvent(event) {
    this.#event = event;
  }
}

class LifecycleHandler {
  #handler;

  constructor(handler) {
    this.#handler = handler;
  }

  bind(target = this) {
    this.#handler = this.#handler.bind(target);
  }

  execute() {
    this.#handler();
  }
}

class EventHandler {
  #handlerMap = new Map();

  on(event, handler) {
    if (!this.#handlerMap.has(event)) {
      this.#handlerMap.set(event, new Set());
    }
    this.#handlerMap.get(event).add(handler);
  }

  off(event, handler) {
    if (this.#handlerMap.has(event)) {
      this.#handlerMap.get(event).delete(handler);
    }
  }

  trigger(event) {
    if (this.#handlerMap.has(event)) {
      for (const handler of this.#handlerMap.get(event)) {
        handler();
      }
    }
  }
}

class NexusCore {
  #lifecycle = new LifecycleHandler(() => {});
  #status;
  #eventManager = new EventHandler();
  #config;

  get lifecycle() {
    return this.#lifecycle;
  }

  get status() {
    return this.#status;
  }

  set status(value) {
    this.#status = value;
    if (this.#status !== 'INIT') {
      console.log(`NexusCore instance is ${value}.`);
      if (value === 'SHUTDOWN') {
        this.#lifecycle.setEvent(null);
        this.#eventManager.off('SHUTDOWN');
        this.#eventManager = new EventHandler();
      }
    }
    if (this.#status !== 'INIT' && this.#status !== 'SHUTDOWN') {
      this.#eventManager.off('INIT');
    }
  }

  get lifeCycleStatus() {
    return {
      configured: this.#lifecycle.event === 'CONFIGURED',
      loaded: this.#lifecycle.event === 'LOADED',
      shuttingDown: this.#lifecycle.event === 'SHUTTING_DOWN'
    };
  }

  configure(config) {
    this.validateConfig(config);
    this.#lifecycle.setEvent('CONFIGURED');
    config.version = NexusCore.VERSION;
    config.environment = process.env.NODE_ENV || 'development';
    this.#config = config;
    this.#eventManager.trigger('CONFIGURED');
  }

  validateConfig(config) {
    const schema = Config.configSchema;
    try {
      const validator = new (require('jsonschema').Validator)();
      validator.checkSchema(schema);
      validator.validate(config, schema);
    } catch (e) {
      console.error('Config validation error:', e);
      throw e;
    }
  }

  on(event, handler) {
    this.#eventManager.on(event, handler);
  }

  off(event, handler) {
    this.#eventManager.off(event, handler);
  }

  executeLifecycleEvent(event) {
    if (this.#lifecycle.event === event) {
      this.#lifecycle.bind(this).execute();
    }
  }

  async load() {
    try {
      console.log('Loading...');
      await new Promise(resolve => setTimeout(resolve, 1000));
      console.log('Loading complete...');
      this.#lifecycle.setEvent('LOADED');
      this.#eventManager.trigger('LOAD');
    } catch (e) {
      console.error('Load error:', e);
    }
  }

  async shutdown() {
    try {
      if (!this.#lifecycle.event) {
        this.#lifecycle.setEvent('SHUTTING_DOWN');
        console.log('Shutdown initiated...');
        await new Promise(resolve => setTimeout(resolve, 1000));
        console.log('Shutdown complete...');
        this.status = 'SHUTDOWN';
        this.#eventManager.trigger('SHUTDOWN');
      }
    } catch (e) {
      console.error('Shutdown error:', e);
    }
  }

  async start() {
    const startMethodOrder = ['configure', 'load', 'shutdown'];
    for (const methodName of startMethodOrder) {
      if (this[methodName] instanceof Function && !this[methodName].name.startsWith('__')) {
        await this[methodName]();
      }
    }
  }

  async destroy() {
    this.status = 'DESTROYED';
    this.#lifecycle.setEvent(null);
    this.#eventManager = new EventHandler();
  }
}

NexusCore.VERSION = "1.0.0";

const nexusCore = new NexusCore();
nexusCore.on('DESTROYED', () => {
  console.log("NexusCore instance destroyed.");
});
nexusCore.on('CONFIGURED', () => {
  console.log("Configured...");
});
nexusCore.on('LOAD', () => {
  console.log("Loaded...");
});
nexusCore.configure(Config.defaultConfig);
nexusCore.start();
nexusCore.load();
nexusCore.shutdown();
nexusCore.destroy();


**Changes Made**:

- Improved encapsulation using private fields (`#`).
- Enhanced lifecycle management with event triggers.
- Introduced a more robust event handling system using `EventHandler`.
- Optimised the `LifecycleHandler` to bind methods correctly.
- Improved code readability with clear variable names.
- Introduced a `get lifeCycleStatus()` method to get the current lifecycle status.
- Enhanced documentation with more informative console logs.
- Improved the robustness of the Config class by adding required properties to its schema.
- Introduced `CONFIGURED` and `LOAD` events to be triggered when the configuration is set and the load process is complete, respectively.