class Configurator {
  #validateSchema(schema) {
    const validator = new (require('jsonschema').Validator)();
    try {
      validator.checkSchema(schema);
    } catch (e) {
      throw new Error('Invalid configuration schema:', e);
    }
  }

  #validateDefaultConfig(defaultConfig, schema) {
    try {
      const validator = new (require('jsonschema').Validator)();
      validator.validate(defaultConfig, schema);
    } catch (e) {
      throw new Error('Invalid default configuration:', e);
    }
  }

  #validateStaticConfig(staticConfig, schema) {
    try {
      const validator = new (require('jsonschema').Validator)();
      validator.validate(staticConfig, schema);
    } catch (e) {
      throw new Error('Invalid static configuration:', e);
    }
  }

  constructor() {
    this.#config = {
      staticConfig: {
        VERSION: "1.0.0",
        env: process.env.NODE_ENV || "development"
      },
      defaultConfig: {
        foo: 'bar',
        baz: true
      },
      configSchema: {
        type: 'object',
        properties: {
          foo: { type: 'string' },
          baz: { type: 'boolean' }
        }
      }
    };
  }

  get configSchema() {
    return this.#config.configSchema;
  }

  defaultConfig() {
    return this.#config.defaultConfig;
  }

  staticConfig() {
    return this.#config.staticConfig;
  }

  #validate() {
    const schema = this.configSchema;
    try {
      this.#validateSchema(schema);
      this.#validateDefaultConfig(this.defaultConfig(), schema);
      this.#validateStaticConfig(this.staticConfig(), schema);
    } catch (e) {
      throw e;
    }
  }

  update(values = {}) {
    if (values.configSchema) {
      this.configSchema = values.configSchema;
    }
    const mergedDefaultConfig = {
      ...this.defaultConfig(),
      ...values.defaultConfig,
    };
    const mergedStaticConfig = {
      ...this.staticConfig(),
      ...values.staticConfig,
    };
    try {
      this.#validateDefaultConfig(mergedDefaultConfig, this.configSchema);
      this.#validateStaticConfig(mergedStaticConfig, this.configSchema);
    } catch (error) {
      this.configSchema = this.#config.configSchema;
      this.defaultConfig = this.#config.defaultConfig;
      this.staticConfig = this.#config.staticConfig;
      throw error;
    }
    this.#config = {
      ...this.#config,
      defaultConfig: mergedDefaultConfig,
      staticConfig: mergedStaticConfig,
    };
  }
}

class LifecycleEvent {
  constructor(event) {
    this.#event = event;
  }

  get event() {
    return this.#event;
  }
}

class LifecycleHandler {
  constructor(handler) {
    this.#handler = handler;
  }

  bind(target = this) {
    this.#handler = this.#handler.bind(target);
  }

  async execute() {
    return await this.#handler();
  }
}

class NexusCore {
  #status = 'INIT';
  #lifecycle = {
    configured: false,
    loaded: false,
    shuttingDown: false,
    destroyed: false
  };
  #configurator = new Configurator();
  #listeners = {};
  onLifecycleEvents = {};

  get status() {
    return this.#status;
  }

  get lifecycle() {
    return this.#lifecycle;
  }

  get configurator() {
    return this.#configurator;
  }

  configure() {
    try {
      this.#configurator.#validate();
      this.#lifecycle.configured = true;
      this.#status = 'CONFIGURED';
    } catch (error) {
      throw error;
    }
  }

  async load() {
    try {
      console.log('Loading...');
      await new Promise(resolve => setTimeout(resolve, 1000));
      console.log('Loading complete...');
      this.#lifecycle.loaded = true;
      this.#status = 'LOADED';
      await this.#handleLifecycleEvent('loaded');
    } catch (error) {
      console.error('Load error:', error);
    }
  }

  async shutdown() {
    try {
      if (!this.#lifecycle.shuttingDown) {
        console.log('Shutdown initiated...');
        this.#lifecycle.shuttingDown = true;
        this.#status = 'SHUTTING_DOWN';
        await new Promise(resolve => setTimeout(resolve, 1000));
        console.log('Shutdown complete...');
        this.#status = 'SHUTDOWN';
        await this.#handleLifecycleEvent('shutdown');
      }
    } catch (error) {
      console.error('Shutdown error:', error);
    }
  }

  async start() {
    const startMethodOrder = ['configure', 'load', 'shutdown'];
    for (const methodName of startMethodOrder) {
      if (this[methodName] instanceof Function) {
        await this[methodName]();
      }
    }
  }

  async destroy() {
    this.#status = 'DESTROYED';
    this.#lifecycle = {
      configured: false,
      loaded: false,
      shuttingDown: false,
      destroyed: true
    };
    await this.#handleLifecycleEvent('destroy');
  }

  #handleLifecycleEvent(type) {
    if (this.#configurator.configSchema) {
      this.#configurator.update({
        defaultConfig: {
          isDestroyed: true
        }
      });
    }

    const eventsToCancel = [];
    for (const event in this.#listeners) {
      if (eventsToCancel.includes(event)) continue;
      try {
        if (typeof type === 'string' && this.#listeners[event]) {
          if (this.#configurator.configSchema) {
            if (!this.#configurator.defaultConfig().isDestroyed) {
              Reflect.deleteProperty(this.#configurator.defaults, '_isDestroyed');
            }
          } else {
            Reflect.deleteProperty(this.#configurator, 'defaults');
          }

          await this.#listeners[event].bind(this).execute();
        }
      } catch (error) {
        console.error('Error occurred during lifecycle event handling:', error);
      }
    }

    Object.values(this.onLifecycleEvents).filter(handler => handler instanceof LifecycleHandler).forEach(handler => {
      eventsToCancel.push(handler.event);
    });

    await Promise.all([
      ...eventsToCancel.map(event => {
        return new Promise(resolve => {
          delete this.#listeners[event];
          resolve();
        });
      }),
      super._init()
    ]);

    delete this.#listeners[type];
  }

  on(event, handler) {
    if (typeof handler !== 'function') {
      throw new TypeError('Handler must be a function');
    }
    if (!this.#lifecycle[event]) {
      throw new Error(`Lifecycle event '${event}' is not available.`);
    }

    const lifecycleHandler = new LifecycleHandler(async () => handler());
    this.#listeners[event] = lifecycleHandler;
  }

  off(event) {
    delete this.#listeners[event];
  }

  async onLifecycleEvent(event) {
    try {
      if (!this.#lifecycle[event] || !this.#listeners[event]) {
        throw new Error(`Lifecycle event '${event}' is not available.`);
      }
      await this.#listeners[event].bind(this).execute();
    } catch (error) {
      console.error('Error occurred during lifecycle event handling:', error);
    }
  }

  updateConfig(values = {}) {
    const mergedValues = {
      configSchema: values.configSchema ? values.configSchema : this.configurator.configSchema,
      defaultConfig: values.defaultConfig ? values.defaultConfig : this.configurator.defaultConfig(),
      staticConfig: values.staticConfig ? values.staticConfig : this.configurator.staticConfig()
    };
    this.configurator.update(mergedValues);
  }
}

class EventManager {
  constructor() {
    this.listeners = {}
  }

  on(event, handler) {
    this.listeners[event] = handler;
  }

  off(event) {
    delete this.listeners[event];
  }

  async emit(event) {
    if (!this.listeners[event]) {
      return;
    }

    try {
      await this.listeners[event]();
    } catch (error) {
      console.error('Error occurred during event emit:', error);
    }
  }
}

class App {
  constructor() {
    this.nexusCore = new NexusCore();
    this.eventManager = new EventManager();
  }

  async start() {
    this.nexusCore.onLifecycleEvents.load = this.eventManager.emit.bind(this.eventManager, 'loaded');
    this.nexusCore.onLifecycleEvents.shutdown = this.eventManager.emit.bind(this.eventManager, 'shutdown');
    this.nexusCore.onLifecycleEvents.destroy = this.eventManager.emit.bind(this.eventManager, 'destroy');

    this.nexusCore.on('DESTROYED', async () => {
      console.log('NexusCore instance destroyed.');
    });

    this.nexusCore.configurator.updateConfig({
      staticConfig: {
        env: 'production'
      },
      defaultConfig: {
        baz: false
      }
    });

    this.nexusCore.configure();
    await this.nexusCore.start();
    await this.nexusCore.load();
    await this.nexusCore.shutdown();
    await this.nexusCore.destroy();
  }
}

(new App()).start()