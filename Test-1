class Config {
  #staticConfig;
  #configSchema;
  #defaultConfig;
  #config;
  #configError;

  constructor() {
    this.configure({});
  }

  configure(values) {
    try {
      Object.freeze(values);
      this.#validateConfig(values);
      this.#config = { ...this.#defaultConfig, ...values };
    } catch (error) {
      this.#config = null;
      this.#configError = error;
    }
  }

  get staticConfig() {
    return {
      VERSION: "1.0.0",
      env: process.env.NODE_ENV || "development"
    };
  }

  get defaultConfig() {
    const staticConfig = this.staticConfig;
    return {
      foo: 'bar',
      baz: true,
      version: staticConfig.VERSION,
      environment: staticConfig.env
    };
  }

  get configSchema() {
    return {
      type: 'object',
      properties: {
        foo: { type: 'string' },
        baz: { type: 'boolean' },
        version: { type: 'string' },
        environment: { type: 'string' }
      },
      required: ['foo', 'baz', 'version', 'environment']
    };
  }

  get isConfigured() {
    return !!this.#config;
  }

  get validationError() {
    return this.#configError;
  }

  get config() {
    return this.#config;
  }

  #validateConfig(config) {
    try {
      const schema = this.configSchema;
      const validator = new (require('jsonschema').Validator)();
      validator.checkSchema(schema);
      validator.validate(config, schema);
    } catch (e) {
      throw new Error(`Invalid configuration: ${e}`);
    }
  }
}

class LifecycleEvent {
  #event;

  constructor(event) {
    this.#event = event;
  }

  get event() {
    return this.#event;
  }
}

class LifecycleHandler {
  constructor(handler) {
    this.handler = handler;
  }

  bind(target = this) {
    return this.handler.bind(target);
  }

  execute() {
    this.handler();
  }
}

class EventHandler {
  #handlers = new Map();

  configure(handler) {
    this.#addHandler('CONFIGURED', handler);
  }

  on(event, handler) {
    this.#addHandler(event, handler);
  }

  #addHandler(event, handler) {
    if (!this.#handlers.has(event)) {
      this.#handlers.set(event, new Set());
    }
    this.#handlers.get(event).add(handler);
  }

  off(event, handler) {
    if (this.#handlers.has(event)) {
      this.#handlers.get(event).delete(handler);
    }
  }

  trigger(event) {
    if (this.#handlers.has(event)) {
      for (const handler of this.#handlers.get(event)) {
        handler();
      }
    }
  }

  offGlobal(handler) {
    for (const handlers of this.#handlers.values()) {
      handlers.delete(handler);
    }
  }
}

class NexusCore {
  #status;
  #config;
  #eventManager = new EventHandler();
  #lifecycle;

  configure() {
    try {
      const config = new Config();
      const configValues = process.env.CONFIGVALUES || "{}";
      config.configure(JSON.parse(configValues));

      this.#config = config;

      const lifecycle = new LifecycleHandler(() => 'CONFIGURED');
      this.#lifecycle = lifecycle;

      this.#eventManager.configure(() => {
        console.log("Configured...");
      });
    } catch (error) {
      console.error('Configuration error:', error);
      throw error;
    }
  }

  async load() {
    console.log('Loading...');
    await new Promise(resolve => setTimeout(resolve, 1000));
    console.log('Loading complete...');
    this.#lifecycle.handler = 'LOADED';
    this.#eventManager.trigger('LOAD');
  }

  shutdown() {
    console.log('Shutdown initiated...');
    return new Promise(resolve => {
      setTimeout(() => {
        console.log('Shutdown complete...');
        this.#status = 'SHUTDOWN';
        this.#eventManager.trigger('SHUTDOWN');
        resolve();
      }, 1000);
    });
  }

  start() {
    this.#status = 'INIT';
    this.configure();
    return new Promise(resolve => {
      resolve();
    });
  }

  destroy() {
    this.#status = 'DESTROYED';
    this.#eventManager = new EventHandler();
  }

  statusChanged(event) {
    const statusUpdateHandler = () => {
      console.log(`NexusCore instance is ${this.#status}.`);
    };
    this.#eventManager.on(event, statusUpdateHandler);
  }

  get status() {
    return this.#status;
  }

  get lifeCycleStatus() {
    return {
      configured: this.#lifecycle.handler === 'CONFIGURED',
      loaded: this.#lifecycle.handler === 'LOADED',
      shuttingDown: false,
      destroyed: this.#status === 'DESTROYED'
    };
  }

  async destroyLater() {
    await this.shutdown();
    await new Promise(resolve => setTimeout(resolve, 1000));
    this.destroy();
  }
}

const nexusCore = new NexusCore();
nexusCore.statusChanged('DESTROYED');
nexusCore.statusChanged('CONFIGURED');
nexusCore.statusChanged('LOAD');
nexusCore.configure();
setTimeout(() => {
  nexusCore.load();
  nexusCore.shutdown();
  nexusCore.destroyLater();
}, 2000);