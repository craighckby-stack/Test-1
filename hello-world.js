• Singleton Pattern: The `globalObj` variable is an example of the Singleton pattern, as it references the globally accessible `global` object in Node.js (or `globalThis` in browser contexts). This ensures that throughout the script, there is only one instance of the `global` object being accessed and used for configuration flags, adhering to the principle of a single, global point of access.
• Factory Pattern: The `doCompileAndReplace` function acts as a factory. It encapsulates the complex process of setting up and executing a compilation command (spawning a `child_process.exec`), managing file system operations (deleting `dist` directory), connecting I/O, and processing the output. It "creates" and orchestrates a full compilation "product" based on the `args` and `prefix` provided.
• Observer Pattern: The `connectIO` function, particularly through its use of `process.stdin`, `process.stdout`, and `process.stderr` piped to and from the `subprocess` streams (`_stdin`, `_stdout`, `_stderr`), establishes an Observer pattern. The main process's standard I/O streams effectively "observe" and react to the data flowing in and out of the subprocess. Additionally, the callback function passed to `cp.exec` acts as an observer for the subprocess's completion or error event.
• Interpreter Pattern: Within `connectIO`, the `stdin`, `stdout`, and `stderr` streams themselves can be seen as components that interpret sequences of bytes as characters or data. While not a classical interpreter for a formal language grammar, these I/O streams are fundamental "interpreters" for the communication between processes, translating raw byte streams into meaningful input and output.
• Command Pattern: The `doCompileAndReplace` function itself embodies the Command pattern. It encapsulates an entire operation ("compile and replace") with all its necessary parameters (`args`, `prefix`, `callback`) and logic. It can be invoked, stored (as done in the `async.series` array), and executed at a later time, effectively decoupling the invoker from the exact action.
• Strategy Pattern: The `deleteFiles` function exemplifies a Strategy pattern for cleaning up the `dist` directory. It provides a specific algorithm (recursive deletion) for a common task. While currently the only deletion strategy, it could conceptually be one of several strategies (e.g., deleting only certain file types, or using a different cleanup mechanism) that could be dynamically chosen.
• Callback Pattern: The entire script heavily relies on the Callback pattern for asynchronous operations. Examples include the `callback` argument in `doCompileAndReplace`, the callback passed to `cp.exec`, the functions within the `async.series` array which all accept a `callback`, and the final callback for `async.series`, as well as `fs.writeFile`. This pattern is used to handle asynchronous results and control flow.
• Pipe and Filter Pattern: The `connectIO` function directly implements the Pipe and Filter pattern by using the `pipe` method of Node.js streams (`pair[0].pipe(pair[1])`). This allows the output of one stream (e.g., `subprocess.stdout`) to be directly fed as input to another stream (`process.stdout`), creating a pipeline where data flows through a series of connected "filters" (the streams themselves, which can transform data) without intermediate storage.