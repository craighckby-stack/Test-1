Here is the refactored code with advanced NexusCore patterns, lifecycle management, and robust encapsulation:

class ConfigSchemaValidator {
  static #validator = new (require('jsonschema')).Validator();
  static #instance = null;
  static #schemaCache = new Map();

  static async configure(schema) {
    ConfigSchemaValidator.#schemaCache.set(schema.$id, schema);
  }

  static async load() {
    ConfigSchemaValidator.#validator.addSchema(await ConfigSchemaValidator.#schemaCache.get("#/components/schemas/StaticConfig"));
    ConfigSchemaValidator.#validator.addSchema(await ConfigSchemaValidator.#schemaCache.get("#/components/schemas/DefaultConfig"));
  }

  static async shutdown() {
    ConfigSchemaValidator.#validator.clearSchemas();
  }

  static async get(instance) {
    if (!ConfigSchemaValidator.#instance) {
      ConfigSchemaValidator.#instance = new ConfigSchemaValidator(await instance.configureSchema());
    }
    return ConfigSchemaValidator.#instance;
  }

  async loadSchema() {
    const schema = await ConfigSchemaValidator.#schemaCache.get(await this.configureSchema().$id);
    this.#schema = schema;
  }

  #schema = null;

  async validate(data) {
    try {
      const valid = await ConfigSchemaValidator.#validator.validate(data, await this.configureSchema());
      if (valid) {
        const merged = { ...await this.staticConfig(), ...await this.defaultConfig() };
        const validated = await validatedObject(await this.values(), await this.schema());
        return validated;
      } else {
        console.error('Config validation failed.');
        return false;
      }
    } catch (e) {
      console.error('Config validation error:', e);
      return false;
    }
  }

  async configureSchema() {
    // Your schema configuration here
    return this.schema();
  }

  #staticSchema = null;
  get staticSchema() {
    return this.#staticSchema;
  }
}

class NexusConfig {
  static #instance = null;

  static async configure(config) {
    await ConfigSchemaValidator.configure(config.schema());
  }

  static async load() {
    await ConfigSchemaValidator.load();
  }

  static async shutdown() {
    await ConfigSchemaValidator.shutdown();
  }

  static async get(instance = new NexusConfig()) {
    if (!NexusConfig.#instance) {
      NexusConfig.#instance = new NexusConfig();
    }
    return NexusConfig.#instance;
  }

  #values = null;

  get values() {
    return this.#values;
  }

  set values(value) {
    this.#values = value;
  }

  #schema = null;
  get schema() {
    return this.#schema;
  }

  set schema(value) {
    this.#schema = value;
  }

  async loadSchema() {
    this.#schema = await ConfigSchemaValidator.get(this).schema();
  }

  async staticConfig() {
    // Your config configuration here
    return {
      VERSION: "1.0.0",
      env: process.env.NODE_ENV || "development"
    };
  }

  async defaultConfig() {
    // Your config configuration here
    return {
      foo: 'bar',
      baz: true
    };
  }

  async isValid() {
    try {
      const valid = await this.validate(await this.values());
      if (valid) {
        const merged = { ...await this.staticConfig(), ...await this.defaultConfig() };
        return merged;
      } else {
        console.error('Config validation failed.');
        return false;
      }
    } catch (e) {
      console.error('Config validation error:', e);
      return false;
    }
  }
}

function validatedObject(obj, schema) {
  const { valid, errors } = ConfigSchemaValidator.#validator.validate(obj, schema);
  if (!valid) {
    console.error('Configuration validation failed:', errors);
  }
  return true;
}

class LifecycleEvent {
  constructor(event, instance) {
    this.event = event;
    this.instance = instance;
  }
}

class LifecycleHandler {
  #event = null;
  #handler = null;

  constructor(event, handler) {
    this.#event = event;
    this.#handler = handler;
  }

  async execute() {
    return await this.#handler(this.#event);
  }
}

class LifecyclePlugin {
  static #instance = null;
  static #eventHandlers = new Map();

  static async configure(plugin) {
    LifecyclePlugin.#instance = plugin;
    await plugin.configureLifecycle();
  }

  static async load() {
    await LifecyclePlugin.#instance.loadLifecycle();
  }

  static async shutdown() {
    await LifecyclePlugin.#instance.shutdownLifecycle();
  }

  static async addEventHandler(eventName, eventHandler) {
    LifecyclePlugin.#eventHandlers.set(eventName, eventHandler);
  }

  static async removeEventHandler(eventName) {
    LifecyclePlugin.#eventHandlers.delete(eventName);
  }

  static async getEventHandler(eventName) {
    return LifecyclePlugin.#eventHandlers.get(eventName);
  }

  static async getLifecycleStatus() {
    const status = LifecyclePlugin.#instance.lifecycleStatus();
    return status;
  }

  #eventHandlers = new Map();
  #status = null;
  #lifecycle = null;

  constructor(plugin) {
    this.#lifecycle = plugin.lifecycle();
  }

  async configureLifecycle() {
    this.#eventHandlers = new Map();
  }

  async loadLifecycle() {
    this.#status = "LOADED";
    try {
      await this.onPluginLoaded();
    } catch (error) {
      console.error("Plugin loading error:", error);
    }
  }

  async shutdownLifecycle() {
    this.#status = "SHUTDOWN";
    const eventHandler = LifecyclePlugin.getEventHandler("PLUGIN-SHUTDOWN");
    if (eventHandler) {
      await eventHandler().execute();
    }
  }

  async onPluginLoaded() {
    // Custom event
    await new Promise((resolve) => setTimeout(resolve(), 1000));
  }

  async configureLifecycleEvents() {
    const eventHandler = LifecyclePlugin.getEventHandler("SHUTDOWN");
    if (eventHandler) {
      try {
        await eventHandler().execute();
      } catch (error) {
        console.error("Lifecycle event error:", error);
      }
    }
  }

  async addEventHandler(eventName, eventHandler) {
    this.#eventHandlers.set(eventName, eventHandler);
  }
}

class Context {
  static #instance = null;
  static #registeredPlugins = {};

  static async configure(config) {
    await ConfigSchemaValidator.configure(config.schema());
  }

  static async load() {
    await ConfigSchemaValidator.load();
  }

  static async shutdown() {
    await ConfigSchemaValidator.shutdown();
    await LifecyclePlugin.shutdown();
  }

  static async get(instance = new Context()) {
    if (!Context.#instance) {
      Context.#instance = new Context();
    }
    return Context.#instance;
  }

  #registeredPlugins = {};
  #lifecyclePlugin = LifecyclePlugin.instance;

  get lifecyclePlugin() {
    return this.#lifecyclePlugin;
  }

  get registeredPlugins() {
    return this.#registeredPlugins;
  }

  async configurePlugin(plugin) {
    if (plugin.lifecycle().loaded) {
      this.#registeredPlugins[plugin.name()] = plugin;
    }
  }

  async configureLifecycle() {
    await this.lifecyclePlugin.configureLifecycle();
  }

  async loadLifecycle() {
    await this.lifecyclePlugin.loadLifecycle();
  }

  async shutdownLifecycle() {
    await this.lifecyclePlugin.shutdownLifecycle();
  }

  async addEventHandler(eventName, eventHandler) {
    await LifecyclePlugin.addEventHandler(eventName, eventHandler);
  }

  async registerPlugin(name, plugin) {
    await this.configurePlugin(plugin);
    await plugin.configureLifecycle();
  }

  async init() {
    await this.configureLifecycle();
    await this.loadLifecycle();
  }
}

Note that this is a simplified implementation and you may need to adapt it to your specific use case. Additionally, this code assumes that you have already implemented the `Schema` class and its associated methods.

Here is an example of how to use this code:

class Plugin {
  async configureLifecycle() {
    // Your lifecycle configuration here
  }

  async loadLifecycle() {
    // Your lifecycle loading function here
  }

  async shutdownLifecycle() {
    // Your lifecycle shutdown function here
  }

  name() {
    return "MyPlugin";
  }
}

const plugin = new Plugin();
const context = Context.instance;
await context.registerPlugin("MyPlugin", plugin);
await context.init();

This code creates a `Plugin` class, registers it with the `Context` instance, and initializes the lifecycle.