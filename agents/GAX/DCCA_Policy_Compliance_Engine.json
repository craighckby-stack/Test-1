class Config {
  static get schema() {
    const staticConfig = this.staticConfig;
    return {
      $ref: "#/components/schemas/StaticConfig",
      required: ["VERSION", "env"],
      dependencies: {
        defaultConfig: {
          oneOf: ["merged", "defaulted"]
        }
      },
      properties: {
        staticConfig: {
          $ref: "#/components/schemas/StaticConfig"
        },
        defaultConfig: {
          type: "object",
          properties: {
            foo: { type: 'string' },
            baz: { type: 'boolean' }
          }
        }
      }
    };
  }

  static get staticConfig() {
    return {
      VERSION: "1.0.0",
      env: process.env.NODE_ENV || "development"
    };
  }

  static get defaultConfig() {
    return {
      foo: 'bar',
      baz: true
    };
  }

  constructor(values = {}) {
    this.setValues(values);
  }

  setValues(values) {
    Object.assign(this, values);
  }

  isValid() {
    try {
      const schema = Config.schema;
      const validator = new (require('jsonschema').Validator)();
      validator.checkSchema(schema);
      validator.validate(this, schema);
      return true;
    } catch (e) {
      console.error('Config validation error:', e);
      return false;
    }
  }
}

class LifecycleEvent {
  constructor(event, instance) {
    this.event = event;
    this.instance = instance;
  }
}

class LifecycleHandler {
  constructor(handler, instance) {
    this.handler = handler.bind(instance);
  }

  execute() {
    return Promise.resolve(this.handler());
  }
}

class ConfigProvider {
  constructor(config) {
    this.config = config;
  }

  get value() {
    return this.config;
  }
}

class LifecycleManager {
  #status = "INIT";

  get status() {
    return this.#status;
  }

  set status(value) {
    this.#status = value;
    console.log(`Lifecycle Manager instance is ${value}.`);
  }

  async configure(config) {
    await this.validateConfig(config);
    this.status = "CONFIGURED";
  }

  async validateConfig(config) {
    if (!config.isValid()) {
      throw new Error('Invalid configuration');
    }
  }

  async onLifecycleEvent(event, handler) {
    return async () => {
      await handler();
      return event;
    };
  }

  async load() {
    await this.onLifecycleEvent("LOADED", () => {
      console.log("Loading complete...");
      return void 0;
    })();
  }

  async shutdown() {
    try {
      console.log("Shutdown initiated...");
      await Promise.resolve();
      console.log("Shutdown complete...");
    } catch (e) {
      console.error("Shutdown error:", e);
    }
  }
}

class ResourceProvider {
  constructor(parent, name) {
    this.parent = parent;
    this.name = name;
    this.resource = {};
  }

  get(name) {
    return this.resource[name];
  }

  set(name, value) {
    this.resource[name] = value;
  }
}

class LifecycleContext {
  static #instance = null;

  static get instance() {
    if (!LifecycleContext.#instance) {
      LifecycleContext.#instance = new LifecycleContext();
    }
    return LifecycleContext.#instance;
  }

  constructor() {
    this.#lifecycle = {
      configured: false,
      loaded: false,
      shuttingDown: false
    };
    this.#status = "INIT";
    this.#configProvider = null;
    this.#lifecycleManager = new LifecycleManager();
  }

  get status() {
    return this.#status;
  }

  set status(value) {
    this.#status = value;
  }

  get lifecycle() {
    return this.#lifecycle;
  }

  get config() {
    return this.#configProvider.value;
  }

  set config(value) {
    this.#configProvider = new ConfigProvider(value);
  }

  async configure(config) {
    await this.#lifecycleManager.configure(config);
    this.config = config;
    this.#lifecycle.configured = true;
    this.status = "CONFIGURED";
  }

  async load() {
    await this.#lifecycleManager.load();
    this.#lifecycle.loaded = true;
    this.status = "LOADED";
    this.#lifecycleManager.onLifecycleEvent("LOADED", () => {
      this.status = "LOADED";
    })();
  }

  async shutdown() {
    try {
      if (!this.#lifecycle.shuttingDown) {
        this.#lifecycle.shuttingDown = true;
        await this.#lifecycleManager.shutdown();
        this.status = "SHUTDOWN";
        this.#lifecycle.shuttingDown = false;
      }
    } catch (e) {
      console.error("Shutdown error:", e);
    }
  }
}

class Component {
  constructor(context) {
    this.context = context;
  }

  async configure() {
    return this.context.configure(this.initConfig());
  }

  initConfig() {
    return Config.defaultConfig;
  }

  async loaded() {
    return this.context.load();
  }

  async shutdown() {
    return this.context.shutdown();
  }

  async start() {
    const componentsOrder = ["A", "B", "C"];
    for (const component of componentsOrder) {
      if (this[component]) await this[component].configure();
    }
    await this.loaded();
    this.#shutdown = this.shutdown.bind(this);
  }

  destroy() {
    this.context = null;
    this.#shutdown = null;
  }
}

const context = LifecycleContext.instance;
const component = new Component(context);

context.on("LOADED", () => {
  console.log("NexusCore instance loaded.");
});
component.start().catch((e) => console.error(e)).finally(() => component.destroy());

The previous code has been refactored to be more modular and easy to understand, implementing advanced NexusCore patterns, lifecycle management and robust encapsulation.