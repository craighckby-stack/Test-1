const LOG_LEVELS = {
    DEBUG: 1,
    INFO: 2,
    WARN: 3,
    ERROR: 4,
    SILENT: 5
};

// --- Internal Fallback Processor ---
// Provides the default logging logic if no global Kernel hook (__CANONICAL_LOG_PROCESSOR__) is provided.
const DefaultLogProcessor = {
    /**
     * @param {{context: string, levelName: string, configLevel: number, messageArgs: any[], levelValue: number}} options
     * @returns {{shouldLog: boolean, consoleMethod: string, prefix: string, payload: any[]}}
     */
    execute(options) {
        const { context, levelName, configLevel, messageArgs, levelValue } = options;
        
        const result = { shouldLog: false, consoleMethod: 'log', prefix: '', payload: messageArgs };

        // 1. Filtering check
        if (levelValue >= configLevel) {
            result.shouldLog = true;
            
            // 2. Formatting
            const timestamp = new Date().toISOString();
            result.prefix = `[${timestamp}] [${levelName}] [${context}]`;
            
            // 3. Output method determination
            result.consoleMethod = levelName.toLowerCase();
        }
        
        return result;
    }
};

/**
 * Standardized Logger utility for engine components.
 * Delegates log formatting and filtering logic to the CanonicalLogProcessorTool plugin if available.
 */
class Logger {
    /** @type {number} */
    #level;
    /** @type {string} */
    #context;

    /**
     * @param {string} context - Identifier for the module or area generating the log (e.g., 'ResolutionStrategyLoader').
     * @param {number} [level=LOG_LEVELS.INFO] - The minimum level to output.
     */
    constructor(context, level = LOG_LEVELS.INFO) {
        this.#context = context;
        this.#level = level;
    }

    /**
     * Resolves the active log processor, checking the global hook.
     * This acts as an I/O proxy for accessing the global scope dependency.
     * @returns {{execute: function}}
     */
    #resolveLogProcessor() {
        if (typeof __CANONICAL_LOG_PROCESSOR__ !== 'undefined' && typeof __CANONICAL_LOG_PROCESSOR__.execute === 'function') {
            return __CANONICAL_LOG_PROCESSOR__;
        }
        return DefaultLogProcessor;
    }

    /**
     * Delegates the log processing request to the provided processor.
     * This acts as an I/O proxy for executing the external dependency.
     * @param {{execute: function}} processor 
     * @param {string} levelName 
     * @param {number} levelValue 
     * @param {any[]} args 
     * @returns {{shouldLog: boolean, consoleMethod: string, prefix: string, payload: any[]}}
     */
    #delegateToProcessorExecution(processor, levelName, levelValue, args) {
        return processor.execute({
            context: this.#context,
            levelName: levelName,
            configLevel: this.#level,
            messageArgs: args,
            levelValue: levelValue
        });
    }

    /**
     * Outputs the final log message using the console API.
     * This acts as an I/O proxy for interaction with the external `console` API.
     * @param {{shouldLog: boolean, consoleMethod: string, prefix: string, payload: any[]}} result
     */
    #delegateToConsoleOutput(result) {
        if (result.shouldLog) {
            // Safely retrieve the console method determined by the plugin
            const consoleMethod = console[result.consoleMethod] || console.log;
            
            // Output the prefix and payload generated by the processor
            if (result.prefix) {
                consoleMethod(result.prefix, ...result.payload);
            } else {
                consoleMethod(...result.payload);
            }
        }
    }

    /**
     * Internal method to process and output logs via the active processor.
     * @param {string} levelName 
     * @param {number} levelValue 
     * @param {...any} args 
     */
    #output(levelName, levelValue, ...args) {
        // 1. Resolve Processor (I/O Proxy)
        const processor = this.#resolveLogProcessor();
        
        // 2. Execute Processor (I/O Proxy)
        const result = this.#delegateToProcessorExecution(
            processor,
            levelName,
            levelValue,
            args
        );
        
        // 3. Output to Console (I/O Proxy)
        this.#delegateToConsoleOutput(result);
    }

    debug(...args) {
        this.#output('DEBUG', LOG_LEVELS.DEBUG, ...args);
    }

    info(...args) {
        this.#output('INFO', LOG_LEVELS.INFO, ...args);
    }

    warn(...args) {
        this.#output('WARN', LOG_LEVELS.WARN, ...args);
    }

    error(...args) {
        this.#output('ERROR', LOG_LEVELS.ERROR, ...args);
    }
}

Logger.Levels = LOG_LEVELS;
export default Logger;