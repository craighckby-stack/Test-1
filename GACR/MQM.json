class Config {
    static get staticConfig() {
        return {
            VERSION: "1.0.0",
            env: process.env.NODE_ENV || "development"
        };
    }

    constructor(values = {}) {
        if (!Config.validateSchema(values)) {
            throw new Error("Invalid configuration schema");
        }
        this.#setValues(values);
    }

    #setValues(values) {
        Object.freeze(Object.assign(this, values));
    }

    static validateSchema(values) {
        const schema = {
            type: 'object',
            properties: {
                VERSION: { type: 'string' },
                env: { type: 'string' }
            },
            required: ['VERSION', 'env']
        };
        try {
            const validator = new (require('jsonschema').Validator)();
            validator.checkSchema(schema);
            validator.validate(values, schema);
        } catch (e) {
            console.error("Config validation error:", e);
            return false;
        }
        return true;
    }

    static get defaultConfig() {
        return {
            foo: 'bar',
            baz: true,
            // Additional properties from staticConfig
            ...Config.staticConfig
        };
    }

    static get configSchema() {
        return {
            type: 'object',
            properties: {
                foo: { type: 'string' },
                baz: { type: 'boolean' }
            },
            // Additional properties from staticConfig
            ...Config.staticConfig
        };
    }
}

class LifecycleEvent {
    #event;

    constructor(event) {
        this.#event = event;
    }

    get event() {
        return this.#event;
    }
}

class LifecycleHandler {
    #handler;

    constructor(handler) {
        if (typeof handler !== 'function') {
            throw new Error("Handler must be a function");
        }
        this.#handler = handler;
    }

    bind(target = this) {
        this.#handler = this.#handler.bind(target);
    }

    execute(...args) {
        this.#handler(...args);
    }

    unbind() {
        this.#handler = null;
    }
}

class NexusCore {
    #privateConfig = {};
    #privateLifecycle = {
        configured: false,
        loaded: false,
        shuttingDown: false
    };
    #privateStatus = "INIT";
    #configLock = false;

    constructor() {
        this.watchLifecycle();
    }

    get config() {
        return Object.freeze(this.#privateConfig);
    }

    get status() {
        return this.#privateStatus;
    }

    set status(value) {
        const currentValue = this.#privateStatus;
        const lifecycle = this.#privateLifecycle;
        if (value !== currentValue) {
            this.#privateStatus = value;
            console.log(`NexusCore instance status changed to ${value}`);
            if (value === 'SHUTDOWN') {
                this.#privateLifecycle.shuttingDown = false;
            }
        }
    }

    get lifecycle() {
        return Object.freeze(this.#privateLifecycle);
    }

    async #validateConfig(config) {
        if (!Config.validateSchema(config)) {
            throw new Error("Invalid configuration schema");
        }
        this.#privateConfig = config;
    }

    async configure(config) {
        if (this.#configLock) {
            throw new Error("Config cannot be set while NexusCore instance is in use");
        }
        this.#configLock = true;
        try {
            await this.#validateConfig(config);
            this.executeLifecycleEvent("CONFIGURED");
            this.#privateLifecycle.configured = true;
        } finally {
            this.#configLock = false;
        }
        return this;
    }

    async load() {
        try {
            console.log("Loading...");
            await new Promise(resolve => setTimeout(resolve, 1000));
            console.log("Loading complete...");
            this.#privateLifecycle.loaded = true;
            this.executeLifecycleEvent("LOADED");
        } catch (e) {
            console.error('Load error:', e);
        }
        return this;
    }

    async shutdown() {
        if (!this.#privateLifecycle.shuttingDown) {
            console.log("Shutdown initiated...");
            this.#privateLifecycle.shuttingDown = true;
            this.executeLifecycleEvent("SHUTTING_DOWN");
            console.log("Shutdown complete...");
            this.status = "SHUTDOWN";
        } else {
            console.log("Shutdown already initiated");
        }
        return this;
    }

    async start() {
        if (this.status !== "INIT") {
            throw new Error("NexusCore instance is already running");
        }
        const startMethodOrder = ["configure", "load", "shutdown"];
        for (const methodName of startMethodOrder) {
            if (this[methodName] instanceof Function) {
                await this[methodName].call(this);
            }
        }
    }

    async destroy() {
        this.status = "DESTROYED";
        this.#privateLifecycle = {
            configured: false,
            loaded: false,
            shuttingDown: false
        };
        this.#privateConfig = {};
    }

    #executeLifecycleEvent(event) {
        if (this.#privateLifecycle[event]) {
            this.#privateLifecycle[event]().unbind().execute();
        }
    }

    async on(event, handler) {
        if (this.#privateLifecycle[event]) {
            throw new Error(`Lifecycle event ${event} is already observed`);
        }
        const lifecycleHandler = new LifecycleHandler(() => {
            this.#privateLifecycle[event].unbind();
        });
        this.#privateLifecycle[event] = lifecycleHandler;
        return lifecycleHandler;
    }

    observe(event) {
        if (!this.#privateLifecycle[event]) {
            throw new Error(`Lifecycle event ${event} is not observed`);
        }
        return new LifecycleEvent(event);
    }

    off(event) {
        this.#privateLifecycle[event] = null;
    }

    watchLifecycle() {
        const observe = this.on.bind(this);
        const lifecycle = this.#privateLifecycle;
        [
            "CONFIGURED",
            "LOADED",
            "SHUTTING_DOWN",
            "DESTROYED"
        ].forEach((event) => {
            const observedEvent = `${event}_observed`;
            lifecycle[observedEvent] = observe(event);
            this.#privateLifecycle[event] = lifecycle[event];
        });
    }
}

async function main() {
    const nexusCore = new NexusCore();
    const lifecycleHandler = nexusCore.on('DESTROYED', () => {
        console.log("NexusCore instance destroyed.");
    }).bind();

    nexusCore.start();
    await nexusCore.load();
    await nexusCore.shutdown();
    nexusCore.destroy();
    console.log(nexusCore.lifecycle);
}

main();