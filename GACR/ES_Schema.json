class Config {
  #instance;
  #configured;
  #configSchema;
  #defaultConfig;
  #initialized;
  #config;
  #logger;

  static #configSchema = {
    type: "object",
    properties: {
      foo: { type: "string" },
      baz: { type: "boolean" }
    }
  };

  static #defaultConfig = {
    foo: "bar",
    baz: true
  };

  static get instance() {
    if (!Config.#instance) {
      Config.#instance = new Config();
    }
    return Config.#instance;
  }

  constructor() {
    this.#logger = new Logger("Config");
    this.#configured = false;
    this.#initialized = false;
    this.#config = {};
  }

  get configured() {
    return this.#configured;
  }

  get initialized() {
    return this.#initialized;
  }

  set initialized(value) {
    this.#initialized = value;
  }

  get config() {
    return this.#config;
  }

  set config(value) {
    this.#config = value;
    this.#initialized = true;
    this.#configured = true;
  }

  async validate(config = this.#config, schema = Config.#configSchema) {
    try {
      if (!(schema instanceof Object)) {
        throw new Error("Schema must be an object");
      }
      const validator = new (require("jsonschema").Validator)();
      await validator.validateAsync(config, schema);
      this.#logger.info("Configuration validated successfully.");
    } catch (e) {
      throw e;
    }
  }

  static async configure(config = Config.#defaultConfig) {
    try {
      await Config.instance.validate(config, Config.#configSchema);
      Config.instance.config = config;
      await Config.instance.#logger.info("Configuration successfully applied.");
    } catch (e) {
      throw e;
    }
  }

  get logger() {
    return this.#logger;
  }
}

class Logger {
  #instance;
  #name;
  #consoleLogger;

  static get instance() {
    if (!Logger.#instance) {
      Logger.#instance = new Logger("default");
    }
    return Logger.#instance;
  }

  constructor(name) {
    this.#name = name;
    this.#consoleLogger = {
      info: (message) => console.log(`${name}: ${message}`),
      error: (message) => console.error(`${name}: ${message}`)
    };
  }

  get consoleLogger() {
    return this.#consoleLogger;
  }

  error(message) {
    this.#consoleLogger.error(message);
  }

  info(message) {
    this.#consoleLogger.info(message);
  }
}

class LifecycleEvent {
  #event;

  constructor(event) {
    this.#event = event;
  }

  get event() {
    return this.#event;
  }
}

class LifecycleHandler {
  #handler;

  constructor(handler) {
    this.#handler = handler;
  }

  async execute(context = LifecycleHandler.prototype) {
    await this.#handler(context);
  }

  bind(target) {
    this.#handler = this.#handler.bind(target);
  }
}

class NexusCore {
  #lifecycle = {
    configured: false,
    loaded: false,
    shuttingDown: false,
    shuttingDownPromise: null,
    shuttingDownResolver: null,
    eventPriority: {
      CONFIGURED: 1,
      LOADED: 2,
      SHUTTING_DOWN: 3,
      DESTROYED: 5
    },
    handlerContext: {}
  };
  #status = "INIT";
  #logger;
  #config;

  constructor() {
    this.#logger = new Logger("NexusCore");
    this.#config = Config.configure();
    Config.instance.#logger = this.#logger;
  }

  get lifecycle() {
    return this.#lifecycle;
  }

  set lifecycle(value) {
    this.#lifecycle = value;
  }

  get status() {
    return this.#status;
  }

  set status(value) {
    this.#status = value;
  }

  get config() {
    return this.#config;
  }

  set config(value) {
    this.#config = value;
  }

  get logger() {
    return this.#logger;
  }

  async on(event, handler) {
    const lifecycle = this.#lifecycle;
    const lifecycleEvent = new LifecycleEvent(event);
    const lifecycleHandler = new LifecycleHandler(async (context) => {
      try {
        await handler(context);
      } catch (e) {
        this.#logger.error(`Lifecycle event handler error: ${event}`, e);
      }
    });
    this.#lifecycle.handlerContext[event] = lifecycleHandler;
    lifecycle[lifecycleEvent.event] = lifecycleHandler;
  }

  async configure() {
    try {
      await Config.configure();
      this.#lifecycle.configured = true;
      this.#status = "CONFIGURED";
    } catch (e) {
      await this.#logger.error("Configure error:", e);
      this.#lifecycle.shuttingDown = true;
      this.#status = "SHUTDOWN";
      throw e;
    }
  }

  async load() {
    try {
      if (this.#lifecycle.configured) {
        this.#logger.info("Loading...");
      }
      this.#logger.info("Loading complete...");
      this.#lifecycle.loaded = true;
      this.#status = "LOADED";
    } catch (e) {
      await this.#logger.error('Load error:', e);
      this.#lifecycle.shuttingDown = true;
      this.#status = "SHUTDOWN";
    }
  }

  async shutdown() {
    if (!this.#lifecycle.shuttingDown) {
      try {
        this.#lifecycle.shuttingDown = true;
        this.#logger.info("Shutdown initiated...");
        return new Promise((resolve) => {
          this.#lifecycle.shuttingDownResolver = resolve;
        });
      } catch (e) {
        await this.#logger.error('Shutdown error:', e);
      }
    } else {
      await this.#logger.info("Shutdown already in progress...");
    }
  }

  async start() {
    await this.configure();
    await this.load();
  }

  async destroy() {
    try {
      this.#lifecycle = {
        configured: false,
        loaded: false,
        shuttingDown: true,
        shuttingDownPromise: null,
        shuttingDownResolver: null
      };
      this.#status = "DESTROYED";
    } catch (e) {
      await this.#logger.error('Destroy error:', e);
    }
  }

  async executeLifecycleEvent(event, handler, priority = this.#lifecycle.eventPriority[event]) {
    const context = this.#lifecycle.handlerContext[event] || this;
    try {
      await handler(context);
      return priority;
    } catch (e) {
      await this.#logger.error(`Lifecycle event handler error: ${event}`, e);
    }
  }

  async execute(event, handler) {
    await this.executeLifecycleEvent(event, handler);
  }
}

const nexusCore = new NexusCore();
nexusCore.configure();
nexusCore.load();
nexusCore.shutdown();
nexusCore.destroy();