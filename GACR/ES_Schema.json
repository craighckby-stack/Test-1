class Config {
  #instance;
  #configured;
  #configSchema;
  #defaultConfig;
  #initialized;
  #config;
  #logger;

  static #configSchema = {
    type: "object",
    properties: {
      foo: { type: "string" },
      baz: { type: "boolean" }
    }
  };

  static #defaultConfig = {
    foo: "bar",
    baz: true
  };

  static get instance() {
    if (!Config.#instance) {
      Config.#instance = new Config();
    }
    return Config.#instance;
  }

  get logger() {
    return this.#logger;
  }

  get configured() {
    return this.#configured;
  }

  get initialized() {
    return this.#initialized;
  }

  get config() {
    return this.#config;
  }

  set config(value) {
    this.#config = value;
    this.#initialized = true;
    this.#configured = true;
  }

  async #handleValidation(config = this.#config, schema = Config.#configSchema) {
    try {
      if (!(schema instanceof Object)) {
        throw new Error("Schema must be an object");
      }
      const validator = new (require("jsonschema").Validator)();
      await validator.validateAsync(config, schema);
      this.#logger.info("Configuration validated successfully.");
    } catch (e) {
      throw e;
    }
  }

  async configure(config = Config.#defaultConfig) {
    try {
      await this.#handleValidation(config, Config.#configSchema);
      Config.instance.config = config;
      await Config.instance.#logger.info("Configuration successfully applied.");
    } catch (e) {
      throw e;
    }
  }
}

class Logger {
  #instance;
  #name;
  #consoleLogger;

  static #instanceMap = new Map();

  static get instance(name = "default") {
    if (!Logger.#instanceMap.has(name)) {
      Logger.#instanceMap.set(name, new Logger(name));
    }
    return Logger.#instanceMap.get(name);
  }

  constructor(name) {
    this.#name = name;
    this.#consoleLogger = {
      info: (message) => console.log(`${name}: ${message}`),
      error: (message) => console.error(`${name}: ${message}`)
    };
  }

  get name() {
    return this.#name;
  }

  get consoleLogger() {
    return this.#consoleLogger;
  }

  error(message) {
    this.#consoleLogger.error(message);
  }

  info(message) {
    this.#consoleLogger.info(message);
  }
}

// Introduced the abstract base class for LifecycleEvent
abstract class LifecycleEvent {
  protected abstract get priority() {
    throw new Error("Subclass must implement priority method");
  }

  constructor() {}
}

class ConfiguredEvent extends LifecycleEvent {
  get priority() {
    return Config.instance.#lifecycle.eventPriority.CONFIGURED;
  }
}

class LoadedEvent extends LifecycleEvent {
  get priority() {
    return Config.instance.#lifecycle.eventPriority.LOADED;
  }
}

class ShuttingDownEvent extends LifecycleEvent {
  get priority() {
    return Config.instance.#lifecycle.eventPriority.SHUTTING_DOWN;
  }
}

class DestroyedEvent extends LifecycleEvent {
  get priority() {
    return Config.instance.#lifecycle.eventPriority.DESTROYED;
  }
}

class LifecycleHandler {
  #handler;
  #context;

  constructor(handler) {
    this.#handler = handler;
  }

  async execute() {
    try {
      await this.#handler(this.#context);
    } catch (e) {
      Config.instance.#logger.error("Lifecycle event handler error", e);
    }
  }

  bind(context) {
    this.#context = context;
  }
}

class NexusCore {
  #lifecycle = {
    configured: false,
    loaded: false,
    shuttingDown: false,
    shuttingDownPromise: null,
    shuttingDownResolver: null,
    eventPriority: {
      CONFIGURED: 1,
      LOADED: 2,
      SHUTTING_DOWN: 3,
      DESTROYED: 5
    },
    handlerContext: {}
  };
  #status = "INIT";
  #logger = Logger.instance("NexusCore");
  #config;

  get lifecycle() {
    return this.#lifecycle;
  }

  set lifecycle(value) {
    this.#lifecycle = value;
  }

  get status() {
    return this.#status;
  }

  set status(value) {
    this.#status = value;
  }

  get config() {
    return this.#config;
  }

  set config(value) {
    this.#config = value;
  }

  get logger() {
    return this.#logger;
  }

  async configure() {
    try {
      await Config.configure();
      this.#lifecycle.configured = true;
      this.#status = "CONFIGURED";
      this.#logger.info("Configuration successfully applied.");
      await this.#onEvent(new ConfiguredEvent());
    } catch (e) {
      await this.#logger.error("Configure error:", e);
      this.#lifecycle.shuttingDown = true;
      this.#status = "SHUTDOWN";
      throw e;
    }
  }

  async load() {
    try {
      if (this.#lifecycle.configured) {
        this.#logger.info("Loading...");
      }
      this.#logger.info("Loading complete...");
      this.#lifecycle.loaded = true;
      this.#status = "LOADED";
      await this.#onEvent(new LoadedEvent());
    } catch (e) {
      await this.#logger.error('Load error:', e);
      this.#lifecycle.shuttingDown = true;
      this.#status = "SHUTDOWN";
    }
  }

  async shutdown() {
    if (!this.#lifecycle.shuttingDown) {
      try {
        this.#lifecycle.shuttingDown = true;
        this.#logger.info("Shutdown initiated...");
        return new Promise((resolve) => {
          this.#lifecycle.shuttingDownResolver = resolve;
        });
      } catch (e) {
        await this.#logger.error('Shutdown error:', e);
      }
    } else {
      await this.#logger.info("Shutdown already in progress...");
    }
    await this.#onEvent(new ShuttingDownEvent());
  }

  async destroy() {
    try {
      this.#lifecycle = {
        configured: false,
        loaded: false,
        shuttingDown: true,
        shuttingDownPromise: null,
        shuttingDownResolver: null
      };
      this.#status = "DESTROYED";
      await this.#onEvent(new DestroyedEvent());
    } catch (e) {
      await this.#logger.error('Destroy error:', e);
    }
  }

  async on(event, handler) {
    if (event instanceof LifecycleEvent) {
      const lifecycleHandler = new LifecycleHandler(handler);
      this.#lifecycle.handlerContext[event.constructor.name] = lifecycleHandler;
      this.#lifecycle[event.constructor.name.toLowerCase()] = lifecycleHandler;
    } else if (typeof handler === "function") {
      const lifecycleHandler = new LifecycleHandler(handler);
      this.#lifecycle.handlerContext[event] = lifecycleHandler;
    } else {
      throw new Error("Invalid event type");
    }
    await this.#onEvent(event);
  }

  async #onEvent(event) {
    try {
      await EventUtil.sortEvents(this.#lifecycle, event);
      const sortedEvents = await EventUtil.executeEventsInOrder(this.#lifecycle, this.#logger);
      this.#status = sortedEvents.lastStatus;
    } catch (e) {
      console.error(e);
    }
  }
}

class EventUtil {
  static async sortEvents(lifecycle, event) {
    for (const key in lifecycle.eventPriority) {
      if (Object.prototype.hasOwnProperty.call(event, key)) {
        event[key] = lifecycle.eventPriority[key];
      }
    }
    return lifecycle.handlerContext[event.constructor.name] || await this.executeHighestPriorityEvent(lifecycle);
  }

  static async executeEventsInOrder(lifecycle, logger = NexusCore.instance.logger) {
    const sortedEvents = Object.keys(lifecycle.handlerContext).reduce((a, b) => {
      if (lifecycle.handlerContext[a].priority > lifecycle.handlerContext[b].priority) {
        [a, b] = [b, a];
      }
      return a;
    }, "").map(async (key) => {
      await lifecycle.handlerContext[key].bind().execute();
      logger.info(`Event ${key} executed.`);
    });
    try {
      await Promise.all(sortedEvents);
      return { lastStatus: NexusCore.instance.status };
    } catch (e) {
      logger.error("Event execution error.", e);
      return { lastStatus: "SHUTDOWN" };
    }
  }

  static async executeHighestPriorityEvent(lifecycle, logger = NexusCore.instance.logger) {
    const sortedEvents = Object.keys(lifecycle.eventPriority).sort((a, b) => {
      return lifecycle.eventPriority[b] - lifecycle.eventPriority[a];
    }).map(key => lifecycle.handlerContext[key] || lifecycle[key]).filter(x => x instanceof LifecycleHandler);
    try {
      await sortedEvents.reduce(async (prev, curr) => {
        await prev;
        return curr.bind().execute();
      }, Promise.resolve());
    } catch (e) {
      logger.error("Event execution error.", e);
      throw e;
    }
  }
}

const nexusCore = new NexusCore();
nexusCore.configure();
nexusCore.load();
nexusCore.shutdown();
nexusCore.destroy();