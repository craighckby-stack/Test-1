class Config {
  static get staticConfig() {
    return {
      VERSION: '1.0.0',
      env: process.env.NODE_ENV || 'development',
    };
  }

  static get defaultConfig() {
    return {
      foo: 'bar',
      baz: true,
    };
  }

  static get schema() {
    return {
      type: 'object',
      properties: {
        foo: { type: 'string' },
        baz: { type: 'boolean' },
      },
      required: ['foo', 'baz'],
    };
  }

  constructor(values = {}) {
    this.#configValues = this.#validate(values);
  }

  #validate(values) {
    const validator = new JSONSchemaValidator();
    validator.validate(values, Config.schema);
    return values;
  }

  get values() {
    return { ...this.#configValues };
  }
}

class JSONSchemaValidator {
  validate(json, schema) {
    this.#schema = schema;
    try {
      this.#json = json;
      this.#validateJson(json);
    } catch (e) {
      throw new Error(`Schema validation error: ${e.message}`);
    }
  }

  #validateJson(json) {
    json = { ...this.#json, ...json };
    Object.keys(json).forEach(key => {
      if (this.#schema.properties[key] != undefined) {
        if (this.#schema.properties[key].type === 'object') {
          json[key] = this.#validateJson(json[key]);
        }
      } else {
        throw new Error(`Property ${key} not found in schema.`);
      }
    });
    Object.keys(this.#schema.required).forEach(key => {
      if (!Object.prototype.hasOwnProperty.call(json, key)) {
        throw new Error(`Required property ${key} not found in JSON.`);
      }
    });
  }

  get errors() {
    return 'Not implemented';
  }

  #json;
  #schema;
}

class LifecycleEvent {
  static create(event, handler) {
    return new LifecycleEvent(event, handler);
  }

  constructor(event, handler) {
    if (typeof event !== 'string') {
      throw new Error('Lifecycle event must be a string.');
    }
    if (typeof handler !== 'function') {
      throw new Error('Lifecycle event handler must be a function.');
    }
    this.#event = event;
    this.#handler = handler;
  }

  get event() {
    return this.#event;
  }

  get handler() {
    return this.#handler;
  }

  bind(target) {
    this.#handler = this.#handler.bind(target);
  }

  #event;
  #handler;
}

class LifecycleEventHandler {
  static create(event, handler) {
    return new LifecycleEvent(event, handler);
  }
}

class NexusCoreStatus {
  static get INIT() {
    return 'INIT';
  }

  static get CONFIGURED() {
    return 'CONFIGURED';
  }

  static get LOADED() {
    return 'LOADED';
  }

  static get SHUTTING_DOWN() {
    return 'SHUTTING_DOWN';
  }

  static get SHUTDOWN() {
    return 'SHUTDOWN';
  }

  static get DESTROYED() {
    return 'DESTROYED';
  }
}

class NexusCoreLifecycle {
  constructor(nexusCore) {
    this.#nexusCore = nexusCore;
    this.#status = NexusCoreStatus.INIT;
    this.#configured = false;
    this.#loaded = false;
    this.#shuttingDown = false;
    this.#handlers = new Map();
  }

  get status() {
    return this.#status;
  }

  set status(value) {
    this.#status = value;
    this.#handleStatusChange(value);
  }

  #handleStatusChange(value) {
    const currentItemStatus = this.#status;
    if (value === NexusCoreStatus.SHUTDOWN) {
      this.#shuttingDown = false;
    }
    if (currentItemStatus === NexusCoreStatus.INIT && value !== NexusCoreStatus.INIT) {
      this.#configured = true;
    }
    this.#nexusCore.executeLifecycleEvent(value);
  }

  configure() {
    this.#configured = true;
    this.#handlers.set("CONFIGURED", LifecycleEventHandler.create(NexusCoreStatus.CONFIGURED, () => {
      console.log("NexusCore instance is configured.");
    }));

    this.#handlers.set("LOADED", LifecycleEventHandler.create(NexusCoreStatus.LOADED, () => {
      console.log("NexusCore instance is loaded.");
    }));
  }

  load() {
    const handler = LifecycleEventHandler.create(NexusCoreStatus.LOADED, () => {
      console.log("NexusCore instance is loaded.");
      this.#loaded = true;
    });
    this.#handlers.set("LOADED", handler);
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        console.log("Loading complete...");
        resolve();
      }, 1000);
    });
  }

  shutdown() {
    const shutdownHandler = LifecycleEventHandler.create(NexusCoreStatus.SHUTDOWN, () => {
      console.log('Shutdown initiated...');
      this.#shuttingDown = false;
      this.status = NexusCoreStatus.SHUTDOWN;
    });
    this.#handlers.set("SHUTDOWN", shutdownHandler);
    this.status = NexusCoreStatus.SHUTTING_DOWN;
  }

  async start() {
    console.log('Starting NexusCore instance...');
    console.log('NexusCore instance is configured.');
    console.log('NexusCore instance is loaded.');
    await this.load();
    this.shutdown();
    await this.destroy();
  }

  async destroy() {
    console.log('Destroying NexusCore instance...');
    this.#loaded = false;
    this.#shuttingDown = false;
    this.status = NexusCoreStatus.DESTROYED;
  }

  executeLifecycleEvent(event) {
    const handler = this.#handlers.get(event);
    if (handler) {
      handler.handler();
    }
  }

  #nexusCore;
  #status;
  #configured;
  #loaded;
  #shuttingDown;
  #handlers;
}

class NexusCore {
  constructor() {
    this.#status = NexusCoreStatus.INIT;
    this.#config = new Config();
    this.#lifecycle = new NexusCoreLifecycle(this);
  }

  get status() {
    return this.#status;
  }

  configure() {
    this.#lifecycle.configure();
  }

  load() {
    return this.#lifecycle.load();
  }

  shutdown() {
    this.#lifecycle.shutdown();
  }

  start() {
    this.#lifecycle.start();
  }

  destroy() {
    this.#lifecycle.destroy();
  }

  executeLifecycleEvent(event) {
    this.#lifecycle.executeLifecycleEvent(event);
  }

  #config;
  #status;
  #lifecycle;
}

const nexusCore = new NexusCore();

nexusCore.configure();

nexusCore.load().then(() => {
  console.log("NexusCore instance is loaded.");
});

nexusCore.shutdown();

nexusCore.start();

nexusCore.destroy();

Note that you will need to install `jsonschema` package to make the code work. You can install it by running the command `npm install jsonschema` in your terminal.