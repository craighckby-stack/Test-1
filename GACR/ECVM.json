class Config {
  static defaultConfig = {
    foo: 'bar',
    baz: true
  };

  static configSchema = {
    type: 'object',
    properties: {
      foo: { type: 'string' },
      baz: { type: 'boolean' }
    }
  };

  static validate(config) {
    try {
      const schema = this.configSchema;
      const validator = new (require('jsonschema').Validator)();
      validator.checkSchema(schema);
      validator.validate(config, schema);
    } catch (e) {
      throw e;
    }
  }
}

class LifecycleEvent extends Error {
  constructor(message = '', code) {
    super(message);
    this.name = 'LIFECYCLE_EVENT';
    this.code = code;
  }
}

class LifecycleHandler {
  constructor(handler) {
    this._handler = handler;
  }

  async execute() {
    try {
      return await this._handler();
    } catch (e) {
      throw new LifecycleEvent('EXECUTION_ERROR', e.message);
    }
  }

  async bind(target = this) {
    const boundHandler = async () => {
      const resolve = target.resolveAsync.bind(target);
      this._handler = this._handler.bind(target);
      return await this._handler();
    };
    boundHandler.resolveAsync = resolve;
    return boundHandler;
  }
}

class SafeAssign {
  constructor(target, values = {}) {
    this._target = target;
    this._values = values;
    this._validated = false;
  }

  copy() {
    const copy = { ...this._target };
    return new SafeAssign(copy, this._values);
  }

  setValues(values) {
    if (!this._validated) {
      this.validate();
      this._validated = true;
    }
    Object.assign(this._target, this._values, values);
  }

  validate() {
    try {
      const schema = Config.configSchema;
      const validator = new (require('jsonschema').Validator)();
      validator.checkSchema(schema);
      validator.validate(this.copy().config, schema);
    } catch (e) {
      throw e;
    }
  }

  get config() {
    return this._target;
  }

  get configCopy() {
    return this.copy().config;
  }
}

class EventEmitter {
  constructor() {
    this._events = {};
  }

  on(event, handler) {
    if (!this._events[event]) {
      this._events[event] = [];
    }
    this._events[event].push(handler);
  }

  off(event, handler) {
    if (this._events[event]) {
      const index = this._events[event].indexOf(handler);
      if (index !== -1) {
        this._events[event].splice(index, 1);
      }
    }
  }

  emit(event, ...args) {
    if (this._events[event]) {
      const copy = [...this._events[event]];
      this._events[event].forEach(handler => handler.bind(this)(...args));
      return copy;
    }
  }

  emitAsync(event, ...args) {
    return new Promise(resolve => {
      const copy = [...this._events[event]];
      this._events[event].forEach(handler => {
        handler.bind(this)(...args).then(resolve);
      });
    });
  }
}

class NexusCore {
  constructor() {
    this._status = 'INIT';
    this._configs = new SafeAssign(Config.defaultConfig);
    this._lifecycle = {
      configured: false,
      loading: false,
      shuttingDown: false,
      destroyed: false,
      started: false
    };
    this.eventEmitter = new EventEmitter();
  }

  get status() {
    return this._status;
  }

  set status(value) {
    this._status = value;
    if (value !== 'INIT') {
      this._lifecycle.configured = true;
    }
  }

  get config() {
    return this._configs;
  }

  get configCopy() {
    return this._configs.copy().config;
  }

  set config(values) {
    this._configs.setValues(values);
    this._configs.validate();
  }

  async configure(config = Config.defaultConfig) {
    if (this._status !== 'INIT') {
      throw new LifecycleEvent('CONFIGURE_ERROR', 'Cannot configure after instance has been started.');
    }
    this.status = 'CONFIGURED';
    await this.eventEmitter.emitAsync('configuring', () => this.config = config);
  }

  async load() {
    if (this._status !== 'CONFIGURED') {
      throw new LifecycleEvent('LOAD_ERROR', 'Cannot load instance that has not been configured.');
    }
    this.status = 'LOADING';
    await this.eventEmitter.emitAsync('loading');
  }

  async shutdown() {
    if (this._status === 'SHUTDOWN' || this._lifecycle.shuttingDown) {
      return;
    }
    this.status = 'SHUTTING_DOWN';
    this._lifecycle.shuttingDown = true;
    await this.eventEmitter.emitAsync('shutting_down');
  }

  async destroy() {
    this.status = 'DESTROYED';
    this._lifecycle.destroyed = true;
  }

  get lifecycle() {
    return this._lifecycle;
  }

  handleEvent(event) {
    switch (event) {
      case 'LOADING':
        this._lifecycle.loading = true;
        break;
      case 'LOADED':
        this._lifecycle.loading = false;
        this._lifecycle.started = true;
        this.status = 'STARTED';
        break;
      case 'SHUTTING_DOWN':
        this._lifecycle.shuttingDown = true;
        this.status = 'SHUTTING_DOWN';
        break;
      case 'SHUTDOWN':
        this._lifecycle.shuttingDown = false;
        this.status = 'SHUTDOWN';
        break;
      case 'DESTROYED':
        this._lifecycle.destroyed = true;
        this.status = 'DESTROYED';
        break;
    }
  }

  eventOnce(event, handler) {
    const boundHandler = handler.bind(this);
    this.eventEmitter.on(event, boundHandler);
    const unbind = () => this.eventEmitter.off(event, boundHandler);
    unbind.onCleanup = unbind;
    return unbind;
  }

  eventEmit(event, ...args) {
    this.eventEmitter.emit(event, ...args);
    this.handleEvent(event);
  }

  async eventEmitAsync(event, ...args) {
    try {
      await this.eventEmitter.emitAsync(event, ...args);
      this.handleEvent(event);
    } catch (e) {
      console.error(e.message);
    }
  }

  async start() {
    const startEventsOrder = ['configuring', 'loading'];
    try {
      await this.eventEmitAsync('startup');
      for (const event of startEventsOrder) {
        await this.eventEmitAsync(event);
      }
      this.status = 'STARTED';
      await this.eventEmitAsync('started');
    } catch (e) {
      console.error(e.message);
    }
  }
}

const instance = () => {
  return new NexusCore();
};

const nexusCore = instance();

nexusCore.eventOnce('DESTRUCTED', () => {
  console.log('NexusCore instance destroyed.');
});

try {
  await nexusCore.configure(Config.defaultConfig);
  await nexusCore.start();
  await nexusCore.load();
  await nexusCore.shutdown();
} finally {
  await nexusCore.destroy();
}

// Example usage:

const eventBinder = nexusCore.eventOnce('CONFIGURED', () => {
  console.log('NexusCore is fully configured.');
});

nexusCore.configure(Config.defaultConfig);

// Make sure to call unbind() to prevent memory leaks
eventBinder.unbind();