class Config {
  #_configSchema = {
    type: 'object',
    properties: {
      foo: { type: 'string' },
      baz: { type: 'boolean' }
    },
    required: ['foo', 'baz']
  };

  constructor(values = {}) {
    this.#validate(values);
    this.#setValues(values);
  }

  #setValues(values) {
    Object.freeze(this.#values = Object.assign({}, { foo: '' }, values));
  }

  #validate(values) {
    const errorMessages = [];
    for (const [key, value] of Object.entries(Config.#_schema(values))) {
      if (key === 'foo') {
        if (!value || !/^[^ ]+$/.test(value)) {
          errorMessages.push(`'${key}' must not be blank and contain only non-space characters.`);
        }
      } else if (key === 'baz') {
        if (typeof value !== 'boolean') {
          errorMessages.push(`'${key}' must be a boolean.`);
        }
      }
    }
    if (errorMessages.length) {
      throw new Error(errorMessages.join('\n'));
    }
  }

  #_schema(values, prefix = '') {
    const result = {};
    for (const [key, value] of Object.entries(this.#_schemaProperties)) {
      if (prefix) {
        result[`${prefix}.${key}`] = value;
      } else {
        result[key] = value;
      }
    }
    return result;
  }

  get schema() {
    return this.#_configSchema;
  }

  get values() {
    return this.#values;
  }

  toJSON() {
    return { ...this.#values };
  }

  static get defaultConfig() {
    return Config.#defaultConfig;
  }

  static get configSchema() {
    return Config.#_configSchema;
  }
}
Config.#defaultConfig = { foo: 'bar', baz: true };

class ConfigValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ConfigValidationError';
    this.status = 400;
  }
}

class LifecycleEvent {
  constructor(event) {
    this.event = event;
  }
}

class LifecycleHandler {
  #eventName;
  #handler;
  #boundHandler;

  constructor(event, handler) {
    this.#eventName = event;
    this.#handler = handler;
    this.#boundHandler = null;
  }

  bind(target = this) {
    this.#boundHandler = this.#handler.bind(target);
  }

  execute() {
    if (this.#boundHandler) {
      this.#boundHandler();
    }
  }

  get handler() {
    return this.#boundHandler;
  }
}

class NexusCore {
  #_lifecycle = {
    configured: false,
    loaded: false,
    shuttingDown: false
  };

  #_status = "INIT";

  #_config;

  get status() {
    return this.#_status;
  }

  set status(value) {
    this.#_status = value;
    const currentValue = this.#_status;
    const lifecycle = this.#_lifecycle;
    if (value !== 'INIT') {
      if (value === 'SHUTDOWN') {
        lifecycle.shuttingDown = false;
      }
    }
    if (currentValue === 'INIT' && value !== 'INIT') {
      lifecycle.configured = true;
    }
  }

  get lifecycle() {
    return this.#_lifecycle;
  }

  async configure(config) {
    await this.validateConfig(config);
    await this.#onLifecycleEvent("CONFIGURED");
    this.#_config = Object.freeze(config);
    return this;
  }

  async #validateConfig(config) {
    try {
      const validator = new (require('jsonschema').Validator)();
      validator.checkSchema(Config.configSchema);
      validator.validate(config, Config.configSchema);
    } catch (e) {
      throw new ConfigValidationError(`Config validation error: ${e}`);
    }
  }

  #onLifecycleEvent(event, handler) {
    if (handler) {
      const lifecycleHandler = new LifecycleHandler(event, handler);
      lifecycleHandler.bind(this);
      this.#_lifecycle[event] = lifecycleHandler;
    }
  }

  async executeLifecycleEvent(event) {
    if (this.#_lifecycle[event]) {
      this.#_lifecycle[event].execute();
    }
  }

  async load() {
    try {
      console.log("Loading...");
      await new Promise(resolve => setTimeout(resolve, 1000));
      await this.executeLifecycleEvent("LOADED");
      console.log("Loading complete...");
    } catch (e) {
      console.error('Load error:', e);
    }
  }

  async shutdown() {
    if (!this.#_lifecycle.shuttingDown) {
      console.log("NexusCore instance is shutting down...");
      await this.executeLifecycleEvent("SHUTTING_DOWN");
      console.log("Shutdown complete...");
      await this.executeLifecycleEvent("SHUTDOWN");
    }
  }

  async start() {
    const startMethodOrder = ["configure", "load", "shutdown"];
    for (const methodName of startMethodOrder) {
      if (this[methodName] instanceof Function) {
        await this[methodName]();
      }
    }
  }

  async destroy() {
    this.status = "DESTROYED";
    this.#_config = undefined;
    this.#_lifecycle = {
      configured: false,
      loaded: false,
      shuttingDown: false
    };
  }

  async on(event, handler) {
    await this.#onLifecycleEvent(event, handler);
  }
}

const nexusCore = new NexusCore();
nexusCore.on('DESTROYED', async () => {
  console.log("NexusCore instance destroyed.");
});
nexusCore.status = 'INIT';
try {
  await nexusCore.configure({ ...Config.defaultConfig });
  await nexusCore.start();
  await nexusCore.load();
  await nexusCore.shutdown();
} catch (e) {
  console.error(e);
  process.exit(1);
}
await nexusCore.destroy();