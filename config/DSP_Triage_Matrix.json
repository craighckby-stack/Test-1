// Import required modules
const genkit = require('genkit');

// Parse the current file using the Genkit parser
const parser = genkit.getCodeParser();
parser.parseFile(__filename, (tree) => {
  // Get the metadata from the current file
  const filePath = __filename;
  const fileDir = path.dirname(filePath);
  const fileName = path.basename(filePath, '.js');

  // Define a new abstract class that will handle configuration
  const configClass = `
    import { Inject, injectable, singleton } from '${genkit.packagesLocation}/genkit';
    import { JsonSchema } from 'jsonschema';
    import { Logger, LogLevel } from '${genkit.packagesLocation}/genkit/packages/logging';

    // Register new metadata in the configuration class
    abstract class Config {
      static readonly logger = new Logger({ level: LogLevel.ALL });

      static readonly defaultConfigSchema = {
        type: 'object',
        properties: {
          metaDirectory: { type: 'string', pattern: '^[\\w\\/]+\\.json$', description: 'path to the metadata file' }
        },
      };

      static readonly defaultEnvironmentConfig = {
        NODE_ENV: 'development',
        LOG_LEVEL: 'debug'
      };

      static get staticEnvironment() {
        const currentNodeEnv = process.env.NODE_ENV;
        return currentNodeEnv ? currentNodeEnv : process.env.NODE_ENV_DEFAULT || 'development';
      }

      constructor(values = {}, container) {
        this.values = values;
        this.container = container;
      }

      abstract init(container: any);

      validateConfig(@Inject('config') config: any, container: any) {
        const configFilePath = `${this.container.resolve('configDir')}config.json`;
        const schemaValidator = new JsonSchema();
        const metaConfig = schemaValidator.validate(config, this.staticEnvironment ? this.defaultEnvironmentConfig.NODE_ENV : 'node');
        return metaConfig;
      }

      get logger() {
        return this.constructor.logger;
      }

      get configFilePath() {
        return this.container.resolve('configDir') + fileName + ".json";
      }

      loadConfig(configObj, options = {}) {
        const configFilePath = this.configFilePath;
        return this.container.resolve('fs').then(() => this.container.resolve('fs').readFile(configFilePath, options))
          .then((content) => {
            this.values = JSON.parse(content);
          })
          .catch((err) => {
            throw err;
          });
      }
    }
  `;

  // Update the AST with the new class definition
  tree.updateClassDeclarations(parser.parse(configClass).functions);

  // Generate the modified code from the updated AST
  const modifiedCode = tree.generateCode({ format: 'esmodule' });

  // Inject the modified code into the current file
  this.exports = modifiedCode;
});