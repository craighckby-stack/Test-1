Here is the refactored code incorporating the higher-order patterns from Firebase/Lifecycle and refining NexusCore's robustness and scalability:



class Config {
  constructor(values = {}) {
    Object.assign(this, this.defaults);
    this.merge(values);
  }

  get defaults() {
    return {
      version: '1.0.0',
      env: 'development',
      foo: 'bar',
      baz: true,
    };
  }

  get schema() {
    return {
      type: 'object',
      default: this.toObject(),
      properties: {
        version: {
          type: 'string',
        },
        env: {
          type: 'string',
        },
        foo: {
          type: 'string',
        },
        baz: {
          type: 'boolean',
        },
      },
    };
  }

  merge(values) {
    Object.assign(this, values);
  }

  validate() {
    const validator = jsonschema.validate(this, this.schema);
    if (validator.errors.length > 0) {
      throw validator;
    }
    return this;
  }

  toObject() {
    return Object.assign({}, this);
  }
}

class LifecycleEvent {
  constructor(event, handler) {
    this.event = event;
    this.handler = handler instanceof Function ? new AsyncHandlerWrapper(handler) : handler;
  }

  isAsync() {
    return this.handler.isAsync();
  }
}

class AsyncHandlerWrapper {
  constructor(handler) {
    this.handler = handler;
  }

  async execute(...args) {
    if (this.handler instanceof Function) {
      return this.handler(...args);
    } else {
      console.error(`Handler: ${this.handler} is not callable.`);
    }
  }

  isAsync() {
    return true;
  }
}

class LifecycleHandler {
  constructor(handler, context) {
    this.handler = handler.bind(context);
  }

  async execute() {
    await this.handler();
  }
}

class Context {
  constructor(values = {}) {
    Object.assign(this, values);
  }

  validate() {
    // implement validation logic here
  }
}

class Lifecycle {
  constructor() {
    this.events = {
      configured: false,
      loaded: false,
      shuttingDown: false,
    };
    this.methods = {
      onCreate: async () => {
        this.events.configured = true;
        this.emit('configured');
      },
      onLoad: async () => {
        this.events.loaded = true;
        this.emit('loaded');
      },
      onConfigured: async () => {
        this.events.configured = true;
        this.emit('configured');
      },
      onShutdown: async () => {
        this.events.shuttingDown = true;
        this.emit('shuttingDown');
      },
      onDestroy: async () => {
        this.dispose();
      },
    };
    this.contextChain = [];
    this.status = 'INIT';
    this.listeners = this.createEventManager();
  }

  constructorLifeCycle() {
    Object.keys(this.methods).forEach((method) => {
      this[method] = this.methods[method];
    });
  }

  getLifecycleEvent(event) {
    return this.listeners.lifecycleHandlers.find((handler) => handler.event === event);
  }

  getLifecycleListeners() {
    return this.listeners;
  }

  getLifecycleHandlers() {
    return this.listeners.lifecycleHandlers;
  }

  dispose() {
    this.listeners.destroy();
  }

  addLifecycleListener(event, handler) {
    this.listeners.on(event, handler);
  }

  createEventManager() {
    class EventManager {
      constructor() {
        this.listeners = {};
      }

      on(event, handler) {
        if (!this.listeners[event]) {
          this.listeners[event] = [];
        }
        this listeners[event].push(handler);
      }

      emit(event, ...args) {
        if (this.listeners[event]) {
          this.listeners[event].forEach((handler) => {
            if (handler.isAsync()) {
              handler.execute(...args).catch((error) => {
                console.error(`Error handling event: ${event}`, error);
              });
            } else {
              handler.execute(...args);
            }
          });
        }
      }

      lifecycleHandlers() {
        return Object.keys(this.listeners).map((event) => {
          return this.listeners[event].map((handler) => {
            return new LifecycleEvent(event, handler);
          });
        });
      }
    }

    return new EventManager();
  }

  async applyLifecycle(event, ...args) {
    await Promise.all(
      this.listeners.lifecycleHandlers.find((handlers) => handlers.event === event).forEach(async (handler) => {
        const lifecycleMethod = this[handler.event];
        if (lifecycleMethod instanceof Function) {
          if (handler.isAsync()) {
            return await lifecycleMethod(...args);
          } else {
            return lifecycleMethod(...args);
          }
        }
      })
    );
  }

  async applyConfig(config) {
    const handler = this.onConfigure.bind(this);
    await handler().then((result) => {
      this.lifecycle('CONFIGURE', config);
    });
  }

  async onConfigure() {
    const lifecycleHandler = this.configureConfig.bind(this);
    return lifecycleHandler();
  }

  configureConfig() {
    this.config = new Config();
    this.config.validate();
    this.config.merge(this.contextChain);
    console.log('Config applied successfully');
  }

  async chainContext(context) {
    this.contextChain = context;
  }

  async load() {
    const lifecycleHandler = this.loadLifecycle.bind(this);
    await lifecycleHandler();
  }

  loadLifecycle() {
    this.events.loaded = true;
    console.log('Load complete');
  }

  async start() {
    const startMethodOrder = ["CONFIGURE", "onLoad", "shutdown"];
    for (const methodName of startMethodOrder) {
      if (this[methodName] instanceof Function) {
        await this[methodName]();
      }
    }
  }

  async shutdown() {
    try {
      if (!this.events.shuttingDown) {
        console.log("Shutdown initiated...");
        this.events.shuttingDown = true;
        this.lifecycle('SHUTTING_DOWN');
        console.log("Shutdown complete...");
        this.status = "SHUTDOWN";
      }
    } catch (e) {
      console.error("Shutdown error:", e);
    }
  }
}

class NexusCore extends Lifecycle {
  constructor() {
    super();
    this.constructorLifeCycle();
  }

  constructorLifeCycle() {
    Object.keys(this.methods).forEach((method) => {
      this[method] = this.methods[method];
    });
  }

  async applyConfig(config) {
    const handler = this.onConfigure.bind(this);
    await handler().then((result) => {
      this.lifecycle('CONFIGURE', config);
    });
  }

  async chainContext(context) {
    await super.chainContext(context);
  }

  async start() {
    const startMethodOrder = ["CONFIGURE", "onLoad", "shutdown"];
    for (const methodName of startMethodOrder) {
      if (this[methodName] instanceof Function) {
        await this[methodName]();
      }
    }
  }

  async shutdown() {
    try {
      if (!this.events.shuttingDown) {
        console.log("Shutdown initiated...");
        this.events.shuttingDown = true;
        this.lifecycle('SHUTTING_DOWN');
        console.log("Shutdown complete...");
        this.status = "SHUTDOWN";
      }
    } catch (e) {
      console.error("Shutdown error:", e);
    }
  }

  async load() {
    await super.load();
  }

  async dispose() {
    super.dispose();
  }

  addLifecycleListener(event, handler) {
    super.addLifecycleListener(event, handler);
  }
}

const instance = new NexusCore();

instance.on('DESTROYED', async () => {
  console.log('NexusCore instance destroyed.');
});

instance.start();