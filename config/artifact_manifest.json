Based on the provided code and directives, I will execute the mutation protocol to transform the code into a more advanced and modern form.

Here is the mutated code:


// Mutated class definitions

class Event {
  constructor(event, payload = {},
    target = new Target(),
    context = {
      lifecycle: lifecycle,
      listeners: listeners
    }) {
    this.event = event;
    this.payload = payload;
    this.target = target;
    this.context = context;
  }
}

class LifecycleHandler {
  constructor(target = new Target(), context = {
    lifecycle: lifecycle,
    listeners: listeners
  }) {
    this.target = target;
    this.context = context;
  }

  async execute(args, lifecycle) {
    if (this.#method) {
      return await this.#handler(...args);
    } else {
      return this.#target.execute(...args);
    }
  }

  bind(target = this) {
    this.#target = target;
    return this;
  }

  async #handler(...args) {
    const result = await super.execute(...args);
    return result !== undefined ? result : null;
  }
}

class Config {
  static #staticConfig = {
    VERSION: '1.0.0',
    env: process.env.NODE_ENV || 'development'
  };

  static get defaultConfig() {
    return {
      foo: 'bar',
      baz: true
    };
  }

  constructor(values = {}, lifecycle = lifecycle, listeners = listeners) {
    if (!this.#lifecycle.has('CONFIGURED')) {
      this.#lifecycle.has('CONFIGURED') && lifecycle.configured && console.error('Configuration not initialized');
      throw new Error('Configuration not initialized');
    }
    this.values = Object.assign({}, Config.defaultConfig, values);
    this.#lifecycle = lifecycle;
    this.listeners = listeners;
  }

  async validate() {
    const schema = Config.configSchema;
    try {
      new Handler('validate', () => {
        new Validator().validate(this.values, schema);
      })();
    } catch (error) {
      this.#messages = error.message;
      return false;
    }
    return true;
  }

  static get configSchema() {
    return {
      type: 'object',
      properties: {
        foo: { type: 'string' },
        baz: { type: 'boolean' }
      },
      required: ['foo', 'baz'],
      additionalProperties: false
    };
  }
}

class Configurator {
  #lifecycle = lifecycle;
  #config = new Config({ foo: 'baz', baz: false });
  #handlers = new Map();

  static get defaultConfig() {
    return {
      foo: 'bar',
      baz: true
    };
  }

  static get namespace() {
    return process.env.NODE_ENV || 'development';
  }

  get config() {
    return this.#config;
  }

  constructor(target = new Target()) {
    Object.values(lifecycle.#events).forEach((event, handler) => {
      lifecycle.#listeners.set(event, handler.bind(this));
      this.#listeners.set(event, handler);
    });
  }

  async configure(config) {
    if (!(config instanceof Config)) {
      throw new Error('Invalid config');
    }
    this.#config = config;
    lifecycle.trigger('CONFIGURED');
  }

  async load() {
    lifecycle.trigger('LOADED');
    this.#config = new Config({
      foo: 'baz',
      baz: false
    });
  }

  async shutdown() {
    lifecycle.trigger('SHUTDOWN_INITIATED');
    lifecycle.#configured = false;
    lifecycle.#loaded = false;
    lifecycle.#shuttingDown = true;
  }
}

class Executor {
  #lifecycle = lifecycle;
  #config = new Config({ foo: 'baz', baz: false });
  #handlers = new Map();

  static get defaultConfig() {
    return {
      foo: 'bar',
      baz: true
    };
  }

  static get namespace() {
    return process.env.NODE_ENV || 'development';
  }

  constructor(target = new Target()) {}

  async execute(event) {
    return this.#handlers.get(event)().then(() => {
      console.log(`\n${event}\n`);
    });
  }

  async executeLifecycle(lifecycle) {
    const event = eventConstructor('EXECUTED', {
      foo: 'baz',
      baz: false
    });
    await this.execute(event);
  }
}

const lifecycle = new Lifecycle();
const events = createEvent();
const validator = new Validator();
const listeners = new Map();

class LifecycleEvent extends LifecycleHandler {
  constructor(event, payload = {}, lifecycle = lifecycle, listeners = listeners) {
    super(event, payload, lifecycle, listeners);
  }

  async execute(...args) {
    return Promise.all(args.filter((argument, index) => index <= this.#argsCount).map((value, index) => {
      const argsCount = this.#argsCount;
      this.#argsCount = index + 1;
      return await this.#handler(value, ...args);
    }));
  }
}

async function main() {
  lifecycle.events.on('DESTROYED', () => {
    console.log("NexusCore instance destroyed.")
  });
  const events = createEvent('LOADED', 'CONFIGURED', 'SHUTDOWN_INITIATED', 'SHUTTING_DOWN', 'DESTROYED');
  events.off();
  await Configurator.create({
    foo: 'baz',
    baz: false
  });
  await Executor.run('EXECUTED');
  console.log("Main function complete.")
}

class Target {
  constructor(target = this) {
    this.target = target;
    this.#initialized = true;
  }
}

const eventConstructor = (event, payload = {},
  lifecycle = lifecycle,
  listeners = listeners) => {

  if (!lifecycle.hasOwnProperty(event)) {
    console.log(lifecycle, event);
    return Promise.reject(`Lifecycle event key not found: ${event}`);
  }
  const Event = new Event(event, payload, lifecycle, listeners).event;
  lifecycle.events.set(Event, new Set())
  return Event;
};

Target.run = (event) => {
  return eventConstructor(event).then((event) => {
    return listeners.get(event)();
  });
}
Target.reset = (method = this.run) => {
  return Promise.all(Object.keys(lifecycle.#events).map((event) => (
    listeners.get(event)()
  ));
}

module.exports = {
  Configurator,
  ConfigValidator,
  LifecycleEvent,
  LifecycleHandler,
  Lifecycle,
  Executor,
  Target,
  lifecycle
}

// Helper functions
const createEvent = (eventKey1, eventKey2, eventKey3, eventKey4, eventKey5) => {
  let event;
  switch (true) {
    case arguments[4] === undefined:
      case (arguments[3] === undefined && arguments[2] === undefined && arguments[1] === undefined):
        event = new Event(eventKey1);
        break;
    case arguments[4] === true:
      event = new Event(eventKey1, eventKey2);
      break;
    default:
      event = new Event(eventKey1, eventKey2, eventKey3);
  }

  const eventConstructor = (eventKey1, eventKey2, eventKey3, eventKey4, eventKey5, eventKey6) => {
    switch (true) {
      case arguments[3] === undefined && arguments[2] === undefined:
        return event(eventKey1, eventKey2);
      case arguments[4] === true:
        return event(eventKey1, eventKey2, eventKey3);
      case arguments[5] === true:
        return event(eventKey1, eventKey2, eventKey3, eventKey4);
      default:
        return event(eventKey1, eventKey2, eventKey3, eventKey4, eventKey5);
    }
  };

  return eventConstructor;
};

const fireEvent = (event, context) => event(context);

const addListener = (event, context, method) => {
  context.events.on(event, method);
  context.listeners.set(event, method);
  return context;
};

const removeListener = (event, method, context = lifecycle) => {
  const eventList = context.events.get(event);
  eventList.delete(method);
  if (eventList.size === 0) {
    context.listeners.delete(event);
  }
  return context;
};

const offListener = (event, method, context = lifecycle) => {
  const eventList = context.listeners.get(event);
  context.listeners.delete(event);
  return eventList.delete(method);
};

const createValidator = (schema) => {
  const validator = new Validator(schema);
  return validator;
};

const validate = (values, schema) => {
  const validator = createValidator(schema);
  try {
    validator.validate(values, schema);
    return true;
  } catch (error) {
    console.error(error);
    return false;
  }
  return true;
}

Note: You will need to install the necessary dependencies before running the code to support the features in the mutated code. 

Please note that some parts might have been changed for clarity and best practices. You might need to adjust them based on the exact requirements of your project.

Also note that you will need to modify the mutated code as per your project's specific requirements.