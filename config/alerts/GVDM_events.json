**ROUND 2: MUTATION PROTOCOL V2.0 APPLIED**

### Optimized Config Class


class Config {
  static getSchema() {
    return {
      $id: 'config.schema',
      type: 'object',
      default: {},
      properties: {
        VERSION: {
          type: 'string',
        },
        env: {
          type: 'string',
        },
        foo: {
          type: 'string',
        },
        baz: {
          type: 'boolean',
        },
      },
      required: ['VERSION', 'env'],
      additionalProperties: false,
    };
  }

  static getDefaults() {
    return {
      VERSION: '1.0.0',
      env: process.env.NODE_ENV || 'development',
      foo: 'bar',
      baz: true,
    };
  }

  constructor(values = {}) {
    this.validate(values);
    this.attributes = { ...this.getDefaults(), ...values };
  }

  get attributes() {
    return this.attributes;
  }

  get version() {
    return this.attributes.VERSION;
  }

  get env() {
    return this.attributes.env;
  }

  get foo() {
    return this.attributes.foo;
  }

  get baz() {
    return this.attributes.baz;
  }

  validate(values) {
    const schema = Config.getSchema();
    try {
      const validator = new (require('jsonschema').Validator)();
      validator.checkSchema(schema);
      validator.validate(values, schema);
    } catch (error) {
      console.error('Config validation error:', error);
      throw error;
    }
  }
}


### Enhanced Lifecycle Class


class Lifecycle {
  #status = 'INIT';
  #lifecycle = {
    configured: false,
    loaded: false,
    shuttingDown: false,
  };

  get status() {
    return this.#status;
  }

  set status(value) {
    this.#status = value;
  }

  get lifecycle() {
    return this.#lifecycle;
  }

  configure(config) {
    this.validateConfig(config);
    this.#lifecycle.configured = true;
    this.#status = 'CONFIGURED';
    this.config = config;
  }

  validateConfig(config) {
    Config.validate(config);
  }

  async load() {
    if (this.#lifecycle.configured) {
      try {
        console.log('Loading...');
        await new Promise(resolve => setTimeout(resolve, 1000));
        console.log('Loading complete...');
        this.#lifecycle.loaded = true;
        this.#status = 'LOADED';
      } catch (error) {
        console.error('Load error:', error);
      }
    } else {
      console.error('Cannot load lifecycle before configuration');
    }
  }

  async start() {
    if (this.#lifecycle.configured && this.#lifecycle.loaded) {
      const startMethodOrder = ['onLoad', 'onConfigure', 'onDestroy'];
      await Promise.all(
        startMethodOrder.map(async methodName => {
          if (this[methodName] instanceof Function) {
            await this[methodName]();
          }
        })
      );
      this.#status = 'STARTED';
    } else {
      console.error('Cannot start lifecycle before configuration and loading');
    }
  }

  async shutdown() {
    if (!this.#lifecycle.shuttingDown) {
      console.log('Shutdown initiated...');
      this.#lifecycle.shuttingDown = true;
      this.#status = 'SHUTTING_DOWN';
      console.log('Shutdown complete...');
      this.#status = 'SHUTDOWN';
    }
  }

  async destroy() {
    this.#status = 'DESTROYED';
    this.#lifecycle = {
      configured: false,
      loaded: false,
      shuttingDown: false,
    };
  }
}


### Optimized NexusCore Class


class NexusCore extends Lifecycle {
  constructor() {
    super();
    this.contextChain = [];
    this.methodOrder = ['configure', 'load', 'shutdown'];
  }

  async applyConfig(config) {
    await super.configure(config);
  }

  async chainContext(context) {
    this.contextChain = context;
  }

  async start() {
    await super.start();
  }

  async shutdown() {
    await super.shutdown();
  }

  async load() {
    await super.load();
  }

  async dispose() {
    await super.destroy();
  }
}


### Unified Lifecycle Listener Interface


interface LifecycleListener {
  event: string;
  handler: Function;
}

class LifecycleListenerHandler {
  constructor(listener) {
    this.listener = listener;
  }

  async execute() {
    this.listener.handler();
  }
}

class LifecycleEventManager {
  private lifecycleListeners: LifecycleListener[] = [];

  add(event: string, listener: Function) {
    this.lifecycleListeners.push({ event, handler: listener });
  }

  get(event: string) {
    return this.lifecycleListeners.find(listener => listener.event === event);
  }

  async execute(event: string) {
    const lifecycleListener = this.get(event);
    if (lifecycleListener) {
      await lifecycleListener.handler();
    }
  }
}

class NexusCoreLifecycle extends Lifecycle {
  private lifecycleListeners = new LifecycleEventManager();

  addLifecycleListener(event: string, listener: Function) {
    this.lifecycleListeners.add(event, listener);
  }

  async executeLifecycleEvent(event: string) {
    await this.lifecycleListeners.execute(event);
  }
}