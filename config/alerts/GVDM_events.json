**Mutated Class Config**


class Config {
  constructor(values = {}) {
    this.merge(this.defaults);
    this.attributes = { ...this.attributes, ...values };
  }

  get defaults() {
    return {
      version: '1.0.0',
      env: 'development',
      foo: 'bar',
      baz: true,
    };
  }

  merge(values) {
    Object.assign(this.attributes, values);
    this.validate();
  }

  validate() {
    const schema = {
      $id: 'config.schema',
      type: 'object',
      default: {},
      properties: {
        version: {
          type: 'string',
        },
        env: {
          type: 'string',
        },
        foo: {
          type: 'string',
        },
        baz: {
          type: 'boolean',
        },
      },
      required: ['version', 'env'],
      additionalProperties: false,
    };
    const validator = jsonschema.validate(this.attributes, schema);
    if (validator.errors.length > 0) {
      throw validator;
    }
  }

  get attributes() {
    return this.attributes;
  }

  get version() {
    return this.attributes.version;
  }

  get env() {
    return this.attributes.env;
  }

  get foo() {
    return this.attributes.foo;
  }

  get baz() {
    return this.attributes.baz;
  }
}


**Enhanced AsyncHandlerWrapper**


class AsyncHandlerWrapper {
  constructor(handler, context) {
    this.handler = handler instanceof Function ? handler.bind(context) : handler;
  }

  async execute(...args) {
    return this.handler(...args);
  }
}


**Optimized Context Class**


class Context {
  constructor(values = {}) {
    this.attributes = { ...this.defaults, ...values };
  }

  get defaults() {
    return {};
  }

  get attributes() {
    return this.attributes;
  }

  validate() {
    // implement validation logic here
  }
}


**Mutated Lifecycle Class**


class Lifecycle {
  #status = 'INIT';
  #lifecycle = {
    configured: false,
    loaded: false,
    shuttingDown: false,
  };

  constructor() {
    this.listeners = new LifecycleEventManager();
  }

  get status() {
    return this.#status;
  }

  set status(value) {
    this.#status = value;
  }

  get lifecycle() {
    return this.#lifecycle;
  }

  async applyLifecycle(event, ...args) {
    const handlers = this.listeners.getLifecycleHandlers(event);
    if (handlers) {
      return Promise.all(
        handlers.map(async (handler) => await handler.execute(...args))
      ).then(() => {
        this.lifecycle[event] = true;
      });
    }
  }

  addLifecycleListener(event, handler) {
    this.listeners.add(event, handler);
  }

  async configure(event, config) {
    this.validateConfig(config);
    this.lifecycle[event] = true;
    this.status = 'CONFIGURED';
    this.config = config;
  }

  validateConfig(config) {
    const schema = {
      $id: 'config.schema',
      type: 'object',
      default: {},
      properties: {
        version: {
          type: 'string',
        },
        env: {
          type: 'string',
        },
        foo: {
          type: 'string',
        },
        baz: {
          type: 'boolean',
        },
      },
      required: ['version', 'env'],
      additionalProperties: false,
    };
    const validator = jsonschema.validate(config, schema);
    if (validator.errors.length > 0) {
      throw validator;
    }
  }

  async applyConfig(event, config) {
    await this.configure(event, config);
  }

  async start(event) {
    switch (event) {
      case 'CONFIGURED':
        return 'Lifecycle configured successfully';
      case 'LOADED':
        return 'Lifecycle loaded successfully';
      default:
        return 'Lifecycle started successfully';
    }
  }

  async shutdown(event) {
    this.lifecycle[event] = true;
    this.status = 'SHUTDOWN';
  }

  async dispose(event) {
    this.status = 'DESTROYED';
    this.lifecycle[event] = false;
  }
}


**Mutated NexusCore Class**


class NexusCore extends Lifecycle {
  constructor() {
    super();
    this.constructorLifeCycle();
    this.listeners = new LifecycleEventManager();
  }

  constructorLifeCycle() {
    this.addLifecycleListener('CONFIGURED', async () => {
      console.log('Lifecycle configured...');
    });

    this.addLifecycleListener('LOADED', async () => {
      console.log('Lifecycle loaded...');
    });

    this.addLifecycleListener('SHUTDOWN', async () => {
      console.log('Lifecycle shutdown...');
    });

    this.addLifecycleListener('DESTROYED', async () => {
      console.log('Lifecycle destroyed...');
    });
  }

  async applyConfig(config) {
    await super.configure('CONFIGURED', config);
  }

  async chainContext(context) {
    this.contextChain = context;
  }

  async start() {
    await super.start('CONFIGURED');
  }

  async shutdown() {
    await super.shutdown('SHUTDOWN');
  }

  async load() {
    await super.start('LOADED');
  }

  async dispose() {
    await super.dispose('DESTROYED');
  }
}


**Unified Lifecycle Listener Interface**


interface LifecycleListener {
  event: string;
  handler: Function;
}

class LifecycleEventManager {
  private listeners: LifecycleListener[] = [];

  add(event: string, listener: Function) {
    this.listeners.push({ event, handler: listener });
  }

  get(event: string) {
    return this.listeners.find(listener => listener.event === event);
  }

  async execute(event: string) {
    const lifecycleListener = this.get(event);
    if (lifecycleListener) {
      await lifecycleListener.handler();
    }
  }
}

class LifecycleListenerHandler {
  constructor(listener: LifecycleListener) {
    this.listener = listener;
  }

  async execute() {
    this.listener.handler();
  }
}