import { promisify } from 'util';
import * as fs from 'fs';
import jsonschema from 'jsonschema';

const _ = {
  chunk: (arr, size) => Array(Math.ceil(arr.length / size)).fill(null).map(function (_, index) {
    return arr.slice(index * size, (index + 1) * size);
  })
};

const Config = class {
  static get configSchema() {
    return _. chunk(this.configSchemaProperties, 4).reduce((acc, group) => ({
      ...acc,
      allOf: _chunk(group, 1).map((properties, index) => ({
        ...acc.allOf[index],
        properties: _chunk(properties, 4).reduce((a, properties, i) => ({
          ...a,
          ...(properties.type === 'object' && {
            properties: Object.keys(properties.properties).reduce((acc, key) => ({
              ...acc,
              [key]: properties.properties[key]
            }), {})
          })
        }), properties.properties)
      }))
    }), { type: 'object' });
  }

  static configSchemaProperties = [
    { type: 'string', default: '1.0.0', description: 'version' },
    { type: 'string', default: 'development', description: 'env' },
    { type: 'string', default: 'bar', description: 'foo' },
    { type: 'boolean', default: true, description: 'baz' }
  ];

  static validateConfig(config) {
    jsonschema.validate(config, Config.configSchema, {
      abortEarly: false,
      format: 'deep',
      schemas: { $ref: 'http://json-schema.org/draft-07/schema#' }
    }).forEach(error => console.error(error));
  }

  static get defaultConfig() {
    return new Config({
      version: '1.0.0',
      env: 'development',
      foo: 'bar',
      baz: true
    });
  }

  constructor(config = {}) {
    Object.assign(this, new Config(config));
  }

  static mergeConfigs(base, ...configs) {
    return configs.reduce(Config.mergeConfigs.bind(base), base);
  }
};

const LifecycleHandler = class {
  constructor(handler, context = {}) {
    this.handler = handler.bind(context);
  }

  execute = promisify(this.handler);
  toAsync = () => this.execute;
};

const onLifecycleEvent = (handler) => (event, context) => new LifecycleHandler(handler, context);

const executeLifecycleEvent = async (lifecycle, event, context = {}) => lifecycle[event].call(context);

class NexusCore {
  async applyConfig(config) {
    Config.validateConfig(config);
    await this.load();
    this.composeConfig(config);
  }

  async load() {
    try {
      const lifecycle = await executeLifecycleEvent(this.lifecycle, 'load');
      if (lifecycle) await lifecycle(this);
    } catch (error) {
      console.error('Load error:', error);
    }
  }

  async composeConfig(config) {
    await this.executeLifecycles('CONFIGURED', config);
  }

  async executeLifecycles(event, ...args) {
    await Promise.all(this.lifecycleMethods.map(async (method) => {
      await this[method]();
      const handler = this.getLifecycleEvent(event);
      if (handler) await handler(...args);
    }));
  }

  async onCreate() {
    this.eventHandlers = {};
    this.lifecycleMethods.forEach(async (method) => {
      const handlerFunc = async (event) => await this[method]();
      this.lifecycle()[method] = handlerFunc.bind(this.lifecycle());
    });
  }

  dispose() {
    Object.keys(this.eventHandlers).forEach((event) => {
      delete this.lifecycle()[event];
    });
  }

  addEventHandler(event, handler) {
    this.lifecycle()[event] = handler;
  }

  getLifecycleEvent(event) {
    return this.lifecycle()[event];
  }

  executeAsync(event) {
    return this.lifecycle()[event].bind(this.lifecycle())();
  }
};

const nexusCore = await NexusCore.createInstance();


Please note that the provided code is an optimized version, which simplifies the existing logic. However, if you're aiming to achieve the `Architectural Singularity`, you may need to introduce new patterns, refactor the existing code, or incorporate more advanced techniques.