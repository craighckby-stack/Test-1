// Define a base class for configurables with robust encapsulation
class Configurable {
  #config;
  #defaults;

  constructor(defaults = {}) {
    this.#defaults = defaults;
    this.#config = { ...defaults };
  }

  get defaultConfig() {
    return this.#defaults;
  }

  get config() {
    return this.#config;
  }

  configure(values = {}) {
    Object.assign(this.#config, values);
  }

  setConfig(value) {
    this.#config = value;
  }

  validate() {
    if (!this.constructor.configSchema) {
      throw new Error('No schema defined for validation');
    }

    const schema = this.constructor.configSchema;
    const validator = new (JSONSchemaBuilder)(schema);
    const { errors } = validator.validate(this.#config);
    if (errors.length > 0) {
      throw new Error('Validation failed');
    }
  }

  freeze() {
    Object.freeze(this.#config);
  }
}

// Update the JSON Schema builder to support asynchronous validation
class JSONSchemaBuilder {
  constructor(schema) {
    this.schema = schema;
  }

  validate(data) {
    return new Promise(resolve => {
      const validator = new (require('jsonschema').Validator)();
      const { errors } = validator.validate(data, this.schema, false);
      resolve({ errors });
    });
  }
}

// Define a base class for lifecycle handlers with type annotations
class LifecycleHandler {
  #handler;

  constructor(handler) {
    this.#handler = handler;
  }

  bind(target) {
    this.#handler = this.#handler.bind(target);
  }

  async execute() {
    return await this.#handler();
  }
}

// Define the Config class with robust encapsulation
class Config extends Configurable {
  static #instance;
  static #configSchema;
  static #frozen;

  static get configSchema() {
    return this.#configSchema;
  }

  static setupConfigSchema(schema) {
    this.#configSchema = schema;
    this.#instance = new Config();
    this.#instance.constructor(schema);
    this.#frozen = true;
  }

  #configSchema = {};

  constructor(values = {}) {
    super(values);
    if (Config.#frozen) {
      throw new Error("Cannot create a new instance, use Config.instance instead");
    }
    this.validate();
    this.freeze();
  }

  static get instance() {
    return Config.#instance;
  }
}

// Define the Configurable constructor method
async function createConfigurable(defaults = {}) {
  const config = new Config(defaults);
  return config;
}

// Define the LifecycleEvent class
class LifecycleEvent {
  #event;

  constructor(event) {
    this.#event = event;
  }

  get event() {
    return this.#event;
  }
}

// Define the NexusCore class with lifecycle management and robust encapsulation
class NexusCore {
  static #instance;
  static #instancePromise;
  static #lifecycle;
  static #status;
  static #config;

  #lifecycle = {
    configured: false,
    loaded: false,
    shuttingDown: false,
  };

  #status = "INIT";

  get status() {
    return this.#status;
  }

  set status(value) {
    this.#status = value;
    if (value !== 'INIT') {
      console.log(`NexusCore instance is ${value}`);
      if (value === 'SHUTDOWN') {
        this.#lifecycle.shuttingDown = false;
      }
    }
  }

  get lifecycle() {
    return this.#lifecycle;
  }

  get configured() {
    return this.lifecycle.configured;
  }

  get loaded() {
    return this.lifecycle.loaded;
  }

  get shuttingDown() {
    return this.lifecycle.shuttingDown;
  }

  config;

  constructor() {
    this.config = await createConfigurable();
  }

  async configure(config) {
    if (NexusCore.constructor.configSchema) {
      for (const property in NexusCore.constructor.configSchema.properties) {
        if (NexusCore.constructor.configSchema.properties[property].default !== undefined) {
          config[property] = config[property] !== undefined ? config[property] : NexusCore.constructor.configSchema.properties[property].default;
        }
      }
    }
    this.config.configure(config);
    this.status = "CONFIGURED";
  }

  static get configSchema() {
    return Config.configSchema;
  }

  static setupConfigSchema(schema) {
    Config.setupConfigSchema(schema);
  }

  async onLifecycleEvent(event, handler) {
    const lifecycleHandler = new LifecycleHandler(handler.bind(this));
    this.#lifecycle[event] = lifecycleHandler;
  }

  async executeLifecycleEvent(event) {
    if (this.#lifecycle[event]) {
      await this.#lifecycle[event].bind(this).execute();
    }
  }

  async asyncLoad() {
    try {
      console.log("Loading...");
      await new Promise(resolve => setTimeout(resolve, 1000));
      console.log("Loading complete...");
      this.#lifecycle.loaded = true;
      await this.executeLifecycleEvent("LOADED");
      this.status = "LOADED";
    } catch (e) {
      console.error('Load error:', e);
      throw e;
    }
  }

  async shutdown() {
    try {
      if (!this.#lifecycle.shuttingDown) {
        console.log("Shutdown initiated...");
        this.#lifecycle.shuttingDown = true;
        await this.executeLifecycleEvent("SHUTTING_DOWN");
        console.log("Shutdown complete...");
        this.status = "SHUTDOWN";
      }
    } catch (e) {
      console.error("Shutdown error:", e);
      throw e;
    }
  }

  async start() {
    if (!NexusCore.#instance) {
      NexusCore.#instance = this;
      NexusCore.#instancePromise = Promise.resolve(this);
    }
    const startMethodOrder = ["configure", "asyncLoad", "shutdown"];
    for (const methodName of startMethodOrder) {
      if (this[methodName] instanceof Function) {
        await this[methodName]();
      }
    }
  }

  async asyncDestroy() {
    if (NexusCore.#instance === this) {
      NexusCore.#instance = undefined;
      NexusCore.#instancePromise = undefined;
    }
    this.status = "DESTROYED";
    this.#lifecycle = {
      configured: false,
      loaded: false,
      shuttingDown: false,
    };
    if (Config.#instance === this) {
      Config.#instance = undefined;
    }
  }

  on(event, handler) {
    this.onLifecycleEvent(event, handler);
    return this;
  }

  static async get instance() {
    if (!NexusCore.#instancePromise) {
      await (NexusCore.instance = new NexusCore());
    }
    return NexusCore.#instancePromise;
  }
}

// Define the NexusCore factory function
async function createNexusCore() {
  return await NexusCore.instance;
}

// Define the main function
async function main() {
  Config.setupConfigSchema({
    $ref: "https://json-schema.org/undefined",
    properties: {
      foo: {
        type: 'string',
        default: 'bar'
      },
      baz: {
        type: 'boolean',
        default: true
      }
    }
  });
  const nexusCore = await createNexusCore();
  await nexusCore.configure({ foo: 'custom-bar', baz: false });
  await nexusCore.asyncLoad();
  await nexusCore.shutdown();
  await nexusCore.asyncDestroy();
}

main();