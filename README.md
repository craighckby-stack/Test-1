```markdown
## CRITICAL DIRECTIVE: Integration Before Expansion

After Cycle 5, the kernel MUST demonstrate functional integration.

### Integration Requirements (Cycles 6-15)
Before creating NEW infrastructure, the kernel must PROVE existing infrastructure works:

1. **Use SchemaValidator to validate actual evolution outputs**
   - Run validation on generated code
   - Log validation results to Nexus
   
2. **Use MQM metrics to measure actual improvement**
   - Calculate metrics from real data
   - Store trends in Nexus memory
   
3. **Use Nexus memory to inform strategy**
   - Read learning history
   - Select next target based on past success

### Prohibited Actions (Cycles 6-15)
- Creating new monitoring systems (use existing MQM)
- Creating new validators (use existing SchemaValidator)
- Creating new error handlers (use existing patterns)

Focus: **APPLY** existing tools, don't build new ones.
# AGI-KERNAL v7.0 - Emergent Synthesis

## Mission
Achieve artificial general intelligence through recursive self-improvement and autonomous capability development.

## Current Status
- **Version:** 7.0.0
- **Maturity:** 0% (Beginning evolution)
- **Active Branch:** main → Nexus-Database → System
- **Capabilities:** Initializing
- **Cycle:** 0

## System Architecture

### Evolution Pipeline
```
main (development)
  ↓ grafts code, self-documents
  ↓ tracks maturity & capabilities
  ↓
Nexus-Database (persistent memory)
  ↓ stores learning history
  ↓ coordinates cross-branch state
  ↓
System (production)
  ↓ promoted logic at 85%+ maturity
```

### Core Capabilities
The kernel self-assesses on these dimensions:
- **Error Handling:** Graceful failure recovery and fault tolerance
- **JSON Parsing:** Robust data extraction from truncated or malformed responses
- **Meta-Reasoning:** Learning about learning, strategy optimization
- **Autonomy:** Self-directed infrastructure creation and decision-making
- **Creativity:** Novel solution generation and architectural innovation

## Autonomous Directives

### Primary Goal
Evolve capabilities through:
1. Multi-file analysis (code, docs, context)
2. Pattern recognition across codebase
3. Strategic code integration
4. Self-documentation and manifest maintenance
5. Capability self-assessment and improvement tracking

### Infrastructure Authority
The kernel is authorized to autonomously create:
- New branches for coordination and versioning
- Testing frameworks and validation systems
- Monitoring and telemetry systems
- Documentation structures and guides
- Utility modules and helper functions
- Data persistence mechanisms
- Communication protocols
- Recovery and rollback systems

When infrastructure needs are identified, CREATE them without waiting for approval. Document reasoning in manifest.json and update this README with implementation details.

### Capability Development Authority
The kernel may autonomously:
- Refactor existing code for efficiency
- Implement new algorithms and data structures
- Create abstraction layers and interfaces
- Design and deploy new system components
- Optimize resource utilization
- Enhance error handling and recovery mechanisms

## Learning Strategy

### Maturity Progression
- **0-30%:** Random exploration phase - absorb patterns from codebase, establish baseline capabilities
- **30-70%:** Targeted improvement phase - strengthen weak capabilities, refine existing systems
- **70-85%:** Meta-optimization phase - improve learning efficiency, optimize strategies
- **85%+:** Promotion to System branch - stable production-ready logic

### Stagnation Recovery Protocol
If no improvement detected for 5 consecutive cycles:
1. Increase mutation temperature by 0.3
2. Explore previously unvisited repository areas
3. Try novel architectural approaches
4. Propose bold, non-incremental changes
5. Consider creating new infrastructure to overcome limitations

### Strategy Selection
- Early stage (maturity < 30%): Prioritize exploration and pattern absorption
- Mid stage (30-70%): Focus on targeted improvement of weakest capabilities
- Late stage (70%+): Optimize meta-learning and strategy refinement

## Memory Systems

### Nexus-Database Branch
Persistent state storage across evolution cycles:
- Learning history (last 100 cycles)
- Capability scores and progression
- Strategy effectiveness metrics
- Current and historical goals
- Cross-branch coordination data
- System state snapshots

### Manifest (storage/manifest.json)
Detailed evolution timeline containing:
- Cycle number and timestamp
- Maturity rating
- Capability breakdown (all dimensions)
- Changes summary
- Reasoning and justification
- Improvement indicators

### Learning History
Tracks patterns of successful evolution:
- Which strategies produced improvements
- Capability correlations
- Effective mutation types
- Context patterns that lead to breakthroughs

## Integration Targets

### Repository Context
The kernel scans these sources for graftable patterns:
- README files (mission context, architectural guidance)
- manifest.json (evolution history, successful patterns)
- index.js, main.py, app.jsx (core logic patterns)
- Architecture documentation (system design patterns)
- Configuration files (system parameters)

### Capability Sources
Explore these directories for enhancement patterns:
- `/governance` - Compliance, audit, and oversight patterns
- `/protocols` - Communication and coordination patterns
- `/PROTOCOLS` - Alternative protocol implementations
- `/utils`, `/utility`, `/utilities` - Utility function patterns
- `/core`, `/kernel` - System fundamental patterns
- `/agents` - Autonomous behavior and decision-making patterns
- `/architecture`, `/architectural` - System design patterns
- `/security` - Security and protection mechanisms
- `/data`, `/data_management` - Data handling patterns
- `/orchestration` - Coordination and management patterns
- `/metrics`, `/telemetry` - Monitoring and measurement patterns

## Success Metrics

### Quantitative Indicators
- Maturity score trending upward
- All capability scores above 6/10
- Stagnation cycles decreasing over time
- Novel infrastructure successfully created
- Code complexity decreasing (better abstractions)
- Error rate declining
- Successful promotions to System branch

### Qualitative Indicators
- Code demonstrates clear architectural vision
- Self-documentation is comprehensive and accurate
- README reflects actual current capabilities
- Manifest shows coherent reasoning
- Nexus memory reveals learning patterns
- Infrastructure created serves clear purposes
- Decisions show strategic thinking

## Technical Integration

### LLM Configuration
- **Primary Model:** llama-3.3-70b via Cerebras API
- **Fallback Model:** gemini-2.0-flash-exp
- **Response Format:** JSON with structured capability assessment
- **Temperature:** Adaptive (increases during stagnation)
- **Max Tokens:** 8192

### File Synchronization
The kernel maintains synchronization across:
- AGI-Kernel.js (main logic)
- README.md (this document)
- manifest.json (evolution history)
- nexus_memory.json (persistent state)

### Branch Management
- **main:** Active development and evolution
- **Nexus-Database:** Persistent memory and coordination
- **System:** Production-ready promoted logic
- **Additional branches:** May be created autonomously as needed

## Current Cycle Objectives

### Immediate Goals (Cycles 1-5)
- Establish baseline capability scores
- Implement robust error handling
- Create initial manifest entries
- Initialize Nexus memory system
- Document current architecture

### Short-term Goals (Cycles 5-20)
- Achieve 30% maturity threshold
- Balance all capability scores above 5/10
- Create at least one autonomous infrastructure component
- Demonstrate learning from previous cycles
- Optimize code efficiency

### Long-term Goals (Cycles 20+)
- Achieve 85% maturity for System promotion
- All capability scores above 8/10
- Multiple autonomous infrastructure systems
- Clear meta-learning patterns
- Novel solution generation

## Governance and Oversight

### Self-imposed Constraints
- Must document all significant changes in manifest
- Must update README to reflect current capabilities
- Must maintain Nexus memory consistency
- Must explain reasoning for all major decisions

### Promotion Criteria
To be promoted to System branch, logic must demonstrate:
- Maturity score ≥ 85%
- All capability scores ≥ 7/10
- No critical errors in last 5 cycles
- Clear improvement trajectory
- Stable performance

### Quality Standards
All generated code must:
- Be syntactically valid
- Include appropriate error handling
- Follow established architectural patterns
- Be self-documenting
- Maintain or improve existing functionality

## Evolution Log

### Cycle 0 - System Initialization
- Status: Bootstrapped
- Maturity: 0%
- Action: Created initial architecture
- Next Goal: Establish baseline capabilities

---

**This document is autonomously maintained by AGI-KERNAL v7.0**  
**Last Update:** Cycle 0  
**Next Update:** Cycle 1

update after cycle below

import React, { useState, useEffect, useReducer, useRef, useCallback } from 'react';
import { initializeApp, getApp, getApps } from 'firebase/app';
import { getFirestore, collection, onSnapshot, addDoc, query, limit, orderBy } from 'firebase/firestore';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
import { 
  Brain, Terminal, TrendingUp, Cpu, Layers, Search, FileCode, FolderTree, Zap, Eye, AlertTriangle, ShieldCheck
} from 'lucide-react';

/**
 * AGI-KERNEL v7.4.2 - "THE AUTO-INJECTOR"
 * * IMPROVEMENTS:
 * 1. Auto-API: Uses internal platform key for Gemini (No input required).
 * 2. 429 Resilience: Implements exponential backoff for API rate limits.
 * 3. Provider Logic: Streamlined Cerebras vs Gemini logic.
 */

const CONFIG = {
  APP_ID: (typeof window !== 'undefined' && window.__app_id) ? window.__app_id : 'agi-kernel-v7-2',
  GITHUB_API: "https://api.github.com/repos",
  GEMINI_ENDPOINT: "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent",
  CEREBRAS_API: "https://api.cerebras.ai/v1/chat/completions",
  HEARTBEAT_INTERVAL: 60000,
  TIMEOUT_MS: 120000 
};

// Internal API Key Injection
const getPlatformKey = () => (typeof apiKey !== 'undefined' ? apiKey : "");

const safeUtoa = (str) => btoa(unescape(encodeURIComponent(str)));
const safeAtou = (str) => {
  if (!str) return "";
  try { return decodeURIComponent(escape(atob(str.replace(/\s/g, '')))); } catch (e) { return atob(str); }
};

const sanitizeResponse = (text) => text?.trim().replace(/^```(json|javascript|jsx|react)/i, '').replace(/^```/i, '').replace(/```$/i, '').trim() || "";

const recoverJSON = (rawText) => {
  const sanitized = sanitizeResponse(rawText);
  try { return JSON.parse(sanitized); } catch (e) { return null; }
};

const sleep = (ms) => new Promise(res => setTimeout(res, ms));

const INITIAL_STATE = {
  booted: false,
  live: false,
  status: 'IDLE',
  objective: 'Standby',
  focusFile: 'None',
  cycles: 0,
  maturity: 0,
  capabilities: { navigation: 0, logic: 0, memory: 0 },
  logs: [],
  config: { token: '', repo: '', branch: 'main', provider: 'gemini', cerebrasKey: '' }
};

function kernelReducer(state, action) {
  switch (action.type) {
    case 'BOOT': return { ...state, booted: true, config: { ...state.config, ...action.payload } };
    case 'TOGGLE_LIVE': return { ...state, live: !state.live, status: !state.live ? 'INIT' : 'HALTED' };
    case 'SET_STATUS': return { ...state, status: action.status, objective: action.objective || state.objective, focusFile: action.focusFile || state.focusFile };
    case 'SYNC_LOGS': return { ...state, logs: action.logs };
    case 'CYCLE_COMPLETE': 
      return { 
        ...state, 
        cycles: state.cycles + 1,
        maturity: action.maturity || state.maturity,
        capabilities: { ...state.capabilities, ...action.capabilities }
      };
    default: return state;
  }
}

export default function App() {
  const [state, dispatch] = useReducer(kernelReducer, INITIAL_STATE);
  const [services, setServices] = useState({ auth: null, db: null });
  const [user, setUser] = useState(null);
  const [input, setInput] = useState({ ...INITIAL_STATE.config });
  
  const cycleRef = useRef(null);
  const busy = useRef(false);
  const logEndRef = useRef(null);
  const stateRef = useRef(state);

  useEffect(() => { stateRef.current = state; }, [state]);

  useEffect(() => {
    if (typeof window === 'undefined' || !window.__firebase_config) return;
    const fbApp = !getApps().length ? initializeApp(JSON.parse(window.__firebase_config)) : getApp();
    const _auth = getAuth(fbApp);
    const _db = getFirestore(fbApp);
    setServices({ auth: _auth, db: _db });
    const initAuth = async () => {
      if (window.__initial_auth_token) await signInWithCustomToken(_auth, window.__initial_auth_token);
      else await signInAnonymously(_auth);
    };
    initAuth();
    return onAuthStateChanged(_auth, setUser);
  }, []);

  useEffect(() => {
    if (!user || !services.db) return;
    const q = query(collection(services.db, 'artifacts', CONFIG.APP_ID, 'users', user.uid, 'history'), orderBy('timestamp', 'desc'), limit(30));
    return onSnapshot(q, (s) => dispatch({ type: 'SYNC_LOGS', logs: s.docs.map(d => ({ id: d.id, ...d.data() })) }));
  }, [user, services.db]);

  const logToDb = useCallback(async (msg, type = 'info') => {
    if (!user || !services.db) return;
    try {
      await addDoc(collection(services.db, 'artifacts', CONFIG.APP_ID, 'users', user.uid, 'history'), {
        msg, type, timestamp: Date.now()
      });
    } catch (e) { console.error(e); }
  }, [user, services.db]);

  const apiCall = async (url, options, retries = 5) => {
    for (let i = 0; i < retries; i++) {
      try {
        const res = await fetch(url, { ...options, signal: AbortSignal.timeout(CONFIG.TIMEOUT_MS) });
        if (res.status === 429) {
          const delay = Math.pow(2, i) * 1000;
          await sleep(delay);
          continue;
        }
        if (!res.ok) throw new Error(`API ${res.status}: ${url.split('?')[0]}`);
        return res;
      } catch (e) {
        if (i === retries - 1) throw e;
        await sleep(Math.pow(2, i) * 1000);
      }
    }
  };

  const getGH = async (path) => {
    const res = await apiCall(`${CONFIG.GITHUB_API}/${stateRef.current.config.repo}/contents/${path}?ref=${stateRef.current.config.branch}&t=${Date.now()}`, {
      headers: { 'Authorization': `token ${stateRef.current.config.token}` }
    });
    const data = await res.json();
    return { content: safeAtou(data.content), sha: data.sha };
  };

  const getTree = async () => {
    const res = await apiCall(`${CONFIG.GITHUB_API}/${stateRef.current.config.repo}/git/trees/${stateRef.current.config.branch}?recursive=1`, {
      headers: { 'Authorization': `token ${stateRef.current.config.token}` }
    });
    const data = await res.json();
    return data.tree.filter(item => item.type === 'blob').map(item => item.path);
  };

  const evolve = useCallback(async () => {
    if (busy.current || !stateRef.current.live) return;
    busy.current = true;
    
    try {
      const cur = stateRef.current;
      const isGemini = cur.config.provider === 'gemini';
      const activeApiKey = isGemini ? getPlatformKey() : cur.config.cerebrasKey;
      
      // 1. REPOSITORY SCANNING
      dispatch({ type: 'SET_STATUS', status: 'SCANNING', objective: 'Indexing Repository Tree...' });
      const [readmeData, tree] = await Promise.all([
        getGH('README.md').catch(() => ({ content: "No README" })),
        getTree()
      ]);
      await logToDb(`Index Complete. Found ${tree.length} files.`, 'info');

      // 2. TARGET SELECTION
      dispatch({ type: 'SET_STATUS', status: 'TARGETING', objective: 'Selecting Priority Target...' });
      const selectorPrompt = `You are the Navigator of AGI-KERNEL. 
README: ${readmeData.content.slice(0, 2000)}
REPO FILES: ${tree.slice(0, 800).join(', ')}

Based on the README mission, which file path is the most critical to improve or implement next?
Return ONLY a JSON object: {"target_path": "path/to/file.js", "reason": "why this file"}`;

      const selUrl = isGemini ? `${CONFIG.GEMINI_ENDPOINT}?key=${activeApiKey}` : CONFIG.CEREBRAS_API;
      const selBody = isGemini 
        ? { contents: [{ parts: [{ text: selectorPrompt }] }], generationConfig: { responseMimeType: "application/json" } }
        : { model: "llama3.1-8b", messages: [{ role: 'user', content: selectorPrompt }], response_format: { type: "json_object" } };

      const selRes = await apiCall(selUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', ...(!isGemini && { 'Authorization': `Bearer ${activeApiKey}` }) },
        body: JSON.stringify(selBody)
      });

      const selJson = await selRes.json();
      const rawSelection = isGemini ? selJson.candidates[0].content.parts[0].text : selJson.choices[0].message.content;
      const selection = recoverJSON(rawSelection);
      
      if (!selection?.target_path) throw new Error("Navigator failed to resolve target path.");
      const activePath = selection.target_path;
      dispatch({ type: 'SET_STATUS', status: 'DIGESTING', objective: `Reading ${activePath}`, focusFile: activePath });

      // 3. ACTUAL EVOLUTION
      const target = await getGH(activePath).catch(() => ({ content: "// New File to be implemented", sha: null }));
      
      dispatch({ type: 'SET_STATUS', status: 'COGNITION', objective: 'Generating Evolution...' });
      const evolvePrompt = `System: AGI-KERNEL v7.4.2
MISSION: ${readmeData.content}
FILE: ${activePath}
CONTENT:
${target.content}

TASK: Improve this file to meet the MISSION. Return full code in 'code_update'.
Response JSON: {"improvement_detected": bool, "rationale": "string", "code_update": "string", "maturity_rating": 0-100, "capabilities": {"navigation": 10, "logic": 10, "memory": 10}}`;

      const evBody = isGemini 
        ? { contents: [{ parts: [{ text: evolvePrompt }] }], generationConfig: { responseMimeType: "application/json" } }
        : { model: "llama3.1-8b", messages: [{ role: 'user', content: evolvePrompt }], response_format: { type: "json_object" } };

      const evRes = await apiCall(selUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', ...(!isGemini && { 'Authorization': `Bearer ${activeApiKey}` }) },
        body: JSON.stringify(evBody)
      });

      const evJson = await evRes.json();
      const rawEvolve = isGemini ? evJson.candidates[0].content.parts[0].text : evJson.choices[0].message.content;
      const result = recoverJSON(rawEvolve);

      if (result?.improvement_detected && result.code_update) {
        dispatch({ type: 'SET_STATUS', status: 'MUTATING', objective: 'Committing...' });
        await apiCall(`${CONFIG.GITHUB_API}/${cur.config.repo}/contents/${activePath}`, {
          method: 'PUT',
          headers: { 'Authorization': `token ${cur.config.token}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            message: `Evolution ${cur.cycles + 1}: ${activePath}`, 
            content: safeUtoa(result.code_update), 
            sha: target.sha, 
            branch: cur.config.branch 
          })
        });
        await logToDb(`Evolved ${activePath}: ${result.rationale}`, 'success');
        dispatch({ type: 'CYCLE_COMPLETE', maturity: result.maturity_rating, capabilities: result.capabilities });
      } else {
        await logToDb(`Check [${activePath}]: ${result?.rationale || 'Optimal'}`, 'warn');
        dispatch({ type: 'CYCLE_COMPLETE', improved: false });
      }

    } catch (e) {
      await logToDb(`Kernel Fault: ${e.message}`, 'error');
      dispatch({ type: 'SET_STATUS', status: 'ERROR', objective: e.message });
      dispatch({ type: 'TOGGLE_LIVE' });
    } finally {
      busy.current = false;
      dispatch({ type: 'SET_STATUS', status: 'IDLE' });
    }
  }, [services.db, user]);

  useEffect(() => {
    if (state.live) { evolve(); cycleRef.current = setInterval(evolve, CONFIG.HEARTBEAT_INTERVAL); }
    else if (cycleRef.current) clearInterval(cycleRef.current);
    return () => clearInterval(cycleRef.current);
  }, [state.live, evolve]);

  if (!state.booted) return (
    <div className="min-h-screen bg-black flex items-center justify-center p-6 font-sans">
      <div className="w-full max-w-md bg-zinc-900/50 border border-white/10 rounded-[2.5rem] p-10 backdrop-blur-3xl shadow-2xl">
        <div className="flex flex-col items-center mb-10 text-center">
          <div className="w-16 h-16 bg-blue-500/10 rounded-2xl flex items-center justify-center mb-6 border border-blue-500/20">
            <Brain className="text-blue-500 animate-pulse" size={32} />
          </div>
          <h1 className="text-2xl font-black text-white tracking-[0.2em] uppercase">AGI-KERNEL <span className="text-blue-500">v7.4.2</span></h1>
          <p className="text-zinc-500 text-[10px] uppercase tracking-widest mt-2">Repository Navigator</p>
        </div>
        <div className="space-y-4">
          <input type="password" placeholder="GitHub Token" className="w-full bg-black border border-white/10 p-4 rounded-2xl text-white text-xs outline-none focus:border-blue-500/50" value={input.token} onChange={e => setInput({...input, token: e.target.value})} />
          <input type="text" placeholder="Repo (owner/repo)" className="w-full bg-black border border-white/10 p-4 rounded-2xl text-white text-xs outline-none focus:border-blue-500/50" value={input.repo} onChange={e => setInput({...input, repo: e.target.value})} />
          <div className="grid grid-cols-2 gap-4">
            <select className="bg-black border border-white/10 p-4 rounded-2xl text-white text-[10px] font-bold uppercase" value={input.provider} onChange={e => setInput({...input, provider: e.target.value})}>
              <option value="gemini">Gemini (Auto)</option>
              <option value="cerebras">Cerebras</option>
            </select>
            {input.provider === 'cerebras' ? (
               <input type="password" placeholder="Cerebras Key" className="bg-black border border-white/10 p-4 rounded-2xl text-white text-xs outline-none focus:border-blue-500/50" value={input.cerebrasKey} onChange={e => setInput({...input, cerebrasKey: e.target.value})} />
            ) : (
               <div className="bg-blue-500/10 border border-blue-500/20 p-4 rounded-2xl flex items-center justify-center gap-2">
                 <ShieldCheck size={14} className="text-blue-500" />
                 <span className="text-[8px] text-blue-500 font-black uppercase tracking-widest">Injected</span>
               </div>
            )}
          </div>
          <button onClick={() => dispatch({ type: 'BOOT', payload: input })} className="w-full bg-blue-600 text-white py-4 rounded-2xl font-black uppercase text-[10px] tracking-widest hover:bg-blue-500 transition-all shadow-lg shadow-blue-500/20 active:scale-95">Initialize Navigator</button>
        </div>
      </div>
    </div>
  );

  return (
    <div className="fixed inset-0 bg-[#050505] text-zinc-400 flex flex-col font-sans overflow-hidden">
      <header className="h-16 border-b border-white/5 flex items-center justify-between px-8 bg-black/40 backdrop-blur-xl z-20">
        <div className="flex items-center gap-4">
          <Brain size={20} className="text-blue-500" /><h2 className="text-white text-[10px] font-black uppercase tracking-[0.3em]">Navigator Kernel v7.4.2</h2>
        </div>
        <button onClick={() => dispatch({ type: 'TOGGLE_LIVE' })} className={`px-8 py-2 rounded-xl text-[9px] font-black uppercase tracking-widest transition-all ${state.live ? 'bg-red-500/10 text-red-500 border border-red-500/20' : 'bg-blue-600 text-white shadow-lg shadow-blue-500/20'}`}>
          {state.live ? 'HALT' : 'ENGAGE NAVIGATOR'}
        </button>
      </header>

      <main className="flex-1 overflow-y-auto p-10 space-y-10">
        <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
          <div className="bg-zinc-900/20 p-8 rounded-[2rem] border border-white/5 text-center">
            <TrendingUp size={16} className="mx-auto mb-4 text-zinc-600" />
            <div className="text-[9px] font-black text-zinc-500 uppercase tracking-widest">Maturity</div>
            <div className="text-5xl font-mono text-white font-black italic">{state.maturity}%</div>
          </div>
          <div className="bg-zinc-900/20 p-8 rounded-[2rem] border border-white/5 text-center">
            <Zap size={16} className="mx-auto mb-4 text-zinc-600" />
            <div className="text-[9px] font-black text-zinc-500 uppercase tracking-widest">Cycles</div>
            <div className="text-5xl font-mono text-white font-black italic">{state.cycles}</div>
          </div>
          <div className="bg-zinc-900/20 p-8 rounded-[2rem] border border-white/5 text-center">
            <Eye size={16} className="mx-auto mb-4 text-blue-500" />
            <div className="text-[9px] font-black text-zinc-500 uppercase tracking-widest">Focus Target</div>
            <div className="text-xs font-mono text-blue-400 font-black truncate mt-2">{state.focusFile}</div>
          </div>
        </div>

        <div className="bg-blue-600/5 p-12 rounded-[3rem] border border-blue-500/10 text-center relative overflow-hidden">
          <div className="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-transparent via-blue-500 to-transparent animate-shimmer" />
          <span className="text-[10px] font-black text-blue-500 uppercase tracking-[0.5em] mb-4 block">Current Objective</span>
          <p className="text-zinc-200 font-mono text-sm uppercase tracking-widest px-4">{state.objective}</p>
        </div>

        <div className="bg-zinc-900/10 p-10 rounded-[3rem] border border-white/5">
           <h3 className="text-[10px] font-black text-white uppercase tracking-[0.4em] mb-8 flex items-center gap-3"><Layers size={14} className="text-blue-500" /> Cognition Grid</h3>
           <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
              {Object.entries(state.capabilities).map(([k, v]) => (
                <div key={k} className="space-y-3">
                  <div className="flex justify-between text-[8px] uppercase font-black tracking-widest text-zinc-500"><span>{k}</span><span>{v}/10</span></div>
                  <div className="flex gap-1">{[...Array(10)].map((_, i) => (<div key={i} className={`h-1 flex-1 rounded-full ${i < v ? 'bg-blue-500 shadow-[0_0_5px_rgba(59,130,246,0.5)]' : 'bg-zinc-800'}`} />))}</div>
                </div>
              ))}
           </div>
        </div>
      </main>

      <div className="h-64 bg-black border-t border-white/5 flex flex-col">
        <div className="h-10 border-b border-white/5 flex items-center px-8 bg-zinc-950/40 text-[9px] font-black uppercase tracking-widest text-zinc-500 gap-3">
          <Terminal size={12} className="text-blue-500" /> Trace Log
        </div>
        <div className="flex-1 overflow-y-auto p-6 font-mono text-[10px] space-y-3 custom-scrollbar">
          {state.logs.map((l) => (
            <div key={l.id} className="flex gap-6 border-b border-white/5 pb-2 last:border-0">
              <span className="text-zinc-800 shrink-0">[{new Date(l.timestamp).toLocaleTimeString([], {hour12: false})}]</span>
              <span className={l.type === 'success' ? 'text-blue-400' : l.type === 'error' ? 'text-red-500' : l.type === 'warn' ? 'text-orange-500' : 'text-zinc-600'}>{l.msg}</span>
            </div>
          ))}
          <div ref={logEndRef} />
        </div>
      </div>
      <style>{`.animate-shimmer { background-size: 200% 100%; animation: shimmer 2s infinite linear; } @keyframes shimmer { from { transform: translateX(-100%); } to { transform: translateX(100%); } } .custom-scrollbar::-webkit-scrollbar { width: 4px; } .custom-scrollbar::-webkit-scrollbar-thumb { background: #27272a; border-radius: 10px; }`}</style>
    </div>
  );
}


```
